/**
 * js/vendor/greensock/CSSPlugin.js
 */

/*    0 */  /*!
      1      * VERSION: beta 1.36
      2      * DATE: 2012-06-23
      3      * JavaScript
      4      * UPDATES AND DOCS AT: http://www.greensock.com
      5      *
      6      * Copyright (c) 2008-2012, GreenSock. All rights reserved.
      7      * This work is subject to the terms in http://www.greensock.com/terms_of_use.html or for
      8      * corporate Club GreenSock members, the software agreement that was issued with the corporate
      9      * membership.
     10      *
     11      * @author: Jack Doyle, jack@greensock.com
     12      */
/*   13 */  (window._gsQueue || (window._gsQueue = [])).push( function() {
/*   14 */  
/*   15 */  	_gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {
/*   16 */  
/*   17 */  		"use strict";
/*   18 */  
/*   19 */  		var CSSPlugin = function() {
/*   20 */  				TweenPlugin.call(this, "css");
/*   21 */  				this._overwriteProps.pop();
/*   22 */  			},
/*   23 */  			p = CSSPlugin.prototype = new TweenPlugin("css");
/*   24 */  
/*   25 */  		p.constructor = CSSPlugin;
/*   26 */  		CSSPlugin.API = 2;
/*   27 */  		CSSPlugin.suffixMap = {top:"px", right:"px", bottom:"px", left:"px", width:"px", height:"px", fontSize:"px", padding:"px", margin:"px"};
/*   28 */  
/*   29 */  		//set up some local variables and functions that we can reuse for all tweens - we do this only once and cache things to improve performance
/*   30 */  		var _NaNExp = /[^\d\-\.]/g,
/*   31 */  			_suffixExp = /(\d|\-|\+|=|#|\.)*/g,
/*   32 */  			_numExp = /(\d|\.)+/g,
/*   33 */  			_opacityExp = /opacity=([^)]*)/,
/*   34 */  			_opacityValExp = /opacity:([^;]*)/,
/*   35 */  			_capsExp = /([A-Z])/g,
/*   36 */  			_camelExp = /-([a-z])/gi,
/*   37 */  			_camelFunc = function(s, g) { return g.toUpperCase() },
/*   38 */  			_horizExp = /(Left|Right|Width)/i,
/*   39 */  			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
/*   40 */  			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
/*   41 */  			_DEG2RAD = Math.PI / 180,
/*   42 */  			_RAD2DEG = 180 / Math.PI,
/*   43 */  			_tempDiv = document.createElement("div"),
/*   44 */  
/*   45 */  			//primarily for older versions of IE
/*   46 */  			_supportsOpacity = (function() {
/*   47 */  				var d = document.createElement("div"), a;
/*   48 */  				d.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>";
/*   49 */  				if (!(a = d.getElementsByTagName("a")[0])) {
/*   50 */  					return false;
/*   51 */  				}
/*   52 */  				return /^0.55/.test(a.style.opacity);
/*   53 */  			})(),
/*   54 */  
/*   55 */  			_ieVers = (function() {
/*   56 */  				(/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(navigator.userAgent);
/*   57 */  				return parseFloat( RegExp.$1 );
/*   58 */  			})(),
/*   59 */  
/*   60 */  			//parses a color (like #9F0, #FF9900, or rgb(255,51,153)) into an array with 3 elements for red, green, and blue. Also handles rgba() values (splits into array of 4 elements of course)
/*   61 */  			_parseColor = function(color) {
/*   62 */  				if (!color || color === "") {
/*   63 */  					return _colorLookup.black;
/*   64 */  				} else if (_colorLookup[color]) {
/*   65 */  					return _colorLookup[color];
/*   66 */  				} else if (typeof(color) === "number") {
/*   67 */  					return [color >> 16, (color >> 8) & 255, color & 255];
/*   68 */  				} else if (color.charAt(0) === "#") {
/*   69 */  					if (color.length === 4) { //for shorthand like #9F0
/*   70 */  						color = "#" + color.charAt(1) + color.charAt(1) + color.charAt(2) + color.charAt(2) + color.charAt(3) + color.charAt(3);
/*   71 */  					}
/*   72 */  					color = parseInt(color.substr(1), 16);
/*   73 */  					return [color >> 16, (color >> 8) & 255, color & 255];
/*   74 */  				} else {
/*   75 */  					return color.match(_numExp) || _colorLookup.transparent;
/*   76 */  				}
/*   77 */  			},
/*   78 */  			_getIEOpacity = function(obj) {
/*   79 */  				return (_opacityExp.test( ((typeof(obj) === "string") ? obj : (obj.currentStyle ? obj.currentStyle.filter : obj.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
/*   80 */  			},
/*   81 */  			_getComputedStyle = (document.defaultView) ? document.defaultView.getComputedStyle : function(o,s) {},
/*   82 */  
/*   83 */  			//gets an individual style property. cs is for computedStyle (a speed optimization - we don't want to run it more than once if we don't have to). calc forces the returned value to be based on the computedStyle, ignoring anything that's in the element's "style" property (computing normalizes certain things for us)
/*   84 */  			_getStyle = function(t, p, cs, calc) {
/*   85 */  				if (!_supportsOpacity && p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
/*   86 */  					return _getIEOpacity(t);
/*   87 */  				} else if (!calc && t.style[p]) {
/*   88 */  					return t.style[p];
/*   89 */  				} else if ((cs = cs || _getComputedStyle(t, null))) {
/*   90 */  					t = cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
/*   91 */  					return (t || cs.length) ? t : cs[p]; //Opera behaves VERY strangely - length is usually 0 and cs[p] is the only way to get accurate results EXCEPT when checking for -o-transform which only works with cs.getPropertyValue()!
/*   92 */  				} else if (t.currentStyle) {
/*   93 */  					return t.currentStyle[p];
/*   94 */  				}
/*   95 */  				return null;
/*   96 */  			},
/*   97 */  
/*   98 */  			//returns at object containing ALL of the style properties in camel-case and their associated values.
/*   99 */  			_getStyles = function(t, cs) {
/*  100 */  				var s = {}, i;
/*  101 */  				if ((cs = cs || _getComputedStyle(t, null))) {
/*  102 */  					if ((i = cs.length)) {
/*  103 */  						while (--i > -1) {
/*  104 */  							s[cs[i].replace(_camelExp, _camelFunc)] = cs.getPropertyValue(cs[i]);
/*  105 */  						}
/*  106 */  					} else { //Opera behaves differently - cs.length is always 0, so we must do a for...in loop.
/*  107 */  						for (i in cs) {
/*  108 */  							s[i] = cs[i];
/*  109 */  						}
/*  110 */  					}
/*  111 */  				} else if ((cs = t.currentStyle || t.style)) {
/*  112 */  					for (i in cs) {
/*  113 */  						s[i.replace(_camelExp, _camelFunc)] = cs[i];
/*  114 */  					}
/*  115 */  				}
/*  116 */  				if (!_supportsOpacity) {
/*  117 */  					s.opacity = _getIEOpacity(t);
/*  118 */  				}
/*  119 */  				var tr = _getTransform(t, cs, false);
/*  120 */  				s.rotation = tr.rotation * _RAD2DEG;
/*  121 */  				s.skewX = tr.skewX * _RAD2DEG;
/*  122 */  				s.scaleX = tr.scaleX;
/*  123 */  				s.scaleY = tr.scaleY;
/*  124 */  				s.x = tr.x;
/*  125 */  				s.y = tr.y;
/*  126 */  				if (s.filters != null) {
/*  127 */  					delete s.filters;
/*  128 */  				}
/*  129 */  				return s;
/*  130 */  			},
/*  131 */  
/*  132 */  			//analyzes two style objects (as returned by _getStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object containing only those isolated properties and values for tweening, and optionally populates an array of those property names too (so that we can loop through them at the end of the tween and remove them for css tweens that apply a className - we don't want the cascading to get messed up)
/*  133 */  			_cssDif = function(s1, s2, v, d) {
/*  134 */  				var s = {}, val, p;
/*  135 */  				for (p in s2) {
/*  136 */  					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] != (val = s2[p])) if (val !== _transformProp) if (typeof(val) === "number" || typeof(val) === "string") {
/*  137 */  						s[p] = val;
/*  138 */  						if (d) {
/*  139 */  							d.props.push(p);
/*  140 */  						}
/*  141 */  					}
/*  142 */  				}
/*  143 */  				if (v) {
/*  144 */  					for (p in v) { //copy properties (except className)
/*  145 */  						if (p !== "className") {
/*  146 */  							s[p] = v[p];
/*  147 */  						}
/*  148 */  					}
/*  149 */  				}
/*  150 */  				return s;
/*  151 */  			},
/*  152 */  			_transformMap = {scaleX:1, scaleY:1, x:1, y:1, rotation:1, shortRotation:1, skewX:1, skewY:1, scale:1},
/*  153 */  
/*  154 */  			_transformProp, //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
/*  155 */  			_prefix, //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".
/*  156 */  			_prefixCSS = (function() { //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
/*  157 */  				var d = document.body || document.documentElement,
/*  158 */  					cs = _getComputedStyle(d, ""),
/*  159 */  					a = ["O","-o-","Moz","-moz-","ms","-ms-","Webkit","-webkit-"],
/*  160 */  					i = 9;
/*  161 */  				while ((i-=2) > -1 && !_getStyle(d, a[i]+"transform", cs)) { }
/*  162 */  				if (i > 0) {
/*  163 */  					_transformProp = (_prefix = a[i-1]) + "Transform";
/*  164 */  					return a[i];
/*  165 */  				}
/*  166 */  				return null;
/*  167 */  			})(),
/*  168 */  			_agent = navigator.userAgent,
/*  169 */  			_reqTransformFix = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && _agent.indexOf("Android") === -1), //non-Android versions of Safari have a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's transform-style to "preserve-3d" (VERY odd, I know).
/*  170 */  
/*  171 */  			//parses the transform values for an element, returning an object with x, y, scaleX, scaleY, rotation, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
/*  172 */  			_getTransform = function(t, cs, rec) {
/*  173 */  				var tm = t._gsTransform, s;
/*  174 */  				if (_transformProp) {
/*  175 */  					s = _getStyle(t, _prefixCSS + "transform", cs, true);
/*  176 */  				} else if (t.currentStyle) {
/*  177 */  					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
/*  178 */  					s = t.currentStyle.filter.match(_ieGetMatrixExp);
/*  179 */  					s = (s && s.length === 4) ? s[0].substr(4) + "," + Number(s[2].substr(4)) + "," + Number(s[1].substr(4)) + "," + s[3].substr(4) + "," + (tm ? tm.x : 0) + "," + (tm ? tm.y : 0) : null;
/*  180 */  				}
/*  181 */  				var v = (s || "").replace(/[^\d\-\.e,]/g, "").split(","),
/*  182 */  					k = (v.length >= 6),
/*  183 */  					a = k ? Number(v[0]) : 1,
/*  184 */  					b = k ? Number(v[1]) : 0,
/*  185 */  					c = k ? Number(v[2]) : 0,
/*  186 */  					d = k ? Number(v[3]) : 1,
/*  187 */  					min = 0.000001,
/*  188 */  					m = rec ? tm || {skewY:0} : {skewY:0},
/*  189 */  					invX = (m.scaleX < 0); //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
/*  190 */  
/*  191 */  				m.x = (k ? Number(v[4]) : 0);
/*  192 */  				m.y = (k ? Number(v[5]) : 0);
/*  193 */  				m.scaleX = Math.sqrt(a * a + b * b);
/*  194 */  				m.scaleY = Math.sqrt(d * d + c * c);
/*  195 */  				m.rotation = (a || b) ? Math.atan2(b, a) : m.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
/*  196 */  				m.skewX = (c || d) ? Math.atan2(c, d) + m.rotation : m.skewX || 0;
/*  197 */  				if (Math.abs(m.skewX) > Math.PI / 2) {
/*  198 */  					if (invX) {
/*  199 */  						m.scaleX *= -1;
/*  200 */  						m.skewX += (m.rotation <= 0) ? Math.PI : -Math.PI;
/*  201 */  						m.rotation += (m.rotation <= 0) ? Math.PI : -Math.PI;
/*  202 */  					} else {
/*  203 */  						m.scaleY *= -1;
/*  204 */  						m.skewX += (m.skewX <= 0) ? Math.PI : -Math.PI;
/*  205 */  					}
/*  206 */  				}
/*  207 */  				//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs().
/*  208 */  				if (m.rotation < min) if (m.rotation > -min) if (a || b) {
/*  209 */  					m.rotation = 0;
/*  210 */  				}
/*  211 */  				if (m.skewX < min) if (m.skewX > -min) if (b || c) {
/*  212 */  					m.skewX = 0;
/*  213 */  				}
/*  214 */  				if (rec) {
/*  215 */  					t._gsTransform = m; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
/*  216 */  				}
/*  217 */  				return m;
/*  218 */  			},
/*  219 */  
/*  220 */  			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
/*  221 */  			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],
/*  222 */  			_getDimension = function(n, t, cs) {
/*  223 */  				var v = parseFloat((n === "width") ? t.offsetWidth : t.offsetHeight),
/*  224 */  					a = _dimensions[n],
/*  225 */  					i = a.length,
/*  226 */  					cs = cs || _getComputedStyle(t, null);
/*  227 */  				while (--i > -1) {
/*  228 */  					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
/*  229 */  					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
/*  230 */  				}
/*  231 */  				return v;
/*  232 */  			},
/*  233 */  
/*  234 */  			//pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number
/*  235 */  			_convertToPixels = function(t, p, v, sfx, recurse) {
/*  236 */  				if (sfx === "px") { return v; }
/*  237 */  				if (sfx === "auto") { return 0; }
/*  238 */  				var horiz = _horizExp.test(p),
/*  239 */  					node = t,
/*  240 */  					neg = (v < 0);
/*  241 */  				if (neg) {
/*  242 */  					v = -v;
/*  243 */  				}
/*  244 */  				_tempDiv.style.cssText = "border-style:solid; border-width:0; position:absolute; line-height:0;";
/*  245 */  				if (sfx === "%" || sfx === "em") {
/*  246 */  					node = t.parentNode || document.body;
/*  247 */  					_tempDiv.style[(horiz ? "width" : "height")] = v + sfx;
/*  248 */  				} else {
/*  249 */  					_tempDiv.style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
/*  250 */  				}
/*  251 */  				node.appendChild(_tempDiv);
/*  252 */  				var pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
/*  253 */  				node.removeChild(_tempDiv);
/*  254 */  				if (pix === 0 && !recurse) { //in some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
/*  255 */  					pix = _convertToPixels(t, p, v, sfx, true);
/*  256 */  				}
/*  257 */  				return neg ? -pix : pix;
/*  258 */  			},
/*  259 */  
/*  260 */  			//for parsing things like transformOrigin or backgroundPosition which must recognize keywords like top/left/right/bottom/center as well as percentages and pixel values. Decorates the supplied object with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
/*  261 */  			_parsePosition = function(v, o) {
/*  262 */  				if (v == null || v === "" || v === "auto") {
/*  263 */  					v = "0 0";
/*  264 */  				}
/*  265 */  				o = o || {};
/*  266 */  				var x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : v.split(" ")[0],
/*  267 */  					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : v.split(" ")[1];
/*  268 */  				if (y == null) {
/*  269 */  					y = "0";
/*  270 */  				} else if (y === "center") {
/*  271 */  					y = "50%";
/*  272 */  				}
/*  273 */  				if (x === "center") {
/*  274 */  					x = "50%";
/*  275 */  				}
/*  276 */  				o.oxp = (x.indexOf("%") !== -1);
/*  277 */  				o.oyp = (y.indexOf("%") !== -1);
/*  278 */  				o.oxr = (x.charAt(1) === "=");
/*  279 */  				o.oyr = (y.charAt(1) === "=");
/*  280 */  				o.ox = parseFloat(x.replace(_NaNExp, ""));
/*  281 */  				o.oy = parseFloat(y.replace(_NaNExp, ""));
/*  282 */  				return o;
/*  283 */  			},
/*  284 */  
/*  285 */  			//takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
/*  286 */  			_parseVal = function(v, d) {
/*  287 */  				return (v == null) ? d : (typeof(v) === "string" && v.indexOf("=") === 1) ? Number(v.split("=").join("")) + d : Number(v);
/*  288 */  			},
/*  289 */  
/*  290 */  			//translates strings like "40deg" or "40" or 40rad" or "+=40deg" to a numeric radian angle, optionally relative to a default value (if "+=" or "-=" prefix is found)
/*  291 */  			_parseAngle = function(v, d) {
/*  292 */  				var m = (v.indexOf("rad") === -1) ? _DEG2RAD : 1,
/*  293 */  					r = (v.indexOf("=") === 1);
/*  294 */  				v = Number(v.replace(_NaNExp, "")) * m;
/*  295 */  				return r ? v + d : v;
/*  296 */  			},
/*  297 */  			_colorLookup = {aqua:[0,255,255],
/*  298 */  							lime:[0,255,0],
/*  299 */  							silver:[192,192,192],
/*  300 */  							black:[0,0,0],
/*  301 */  							maroon:[128,0,0],
/*  302 */  							teal:[0,128,128],
/*  303 */  							blue:[0,0,255],
/*  304 */  							navy:[0,0,128],
/*  305 */  							white:[255,255,255],
/*  306 */  							fuchsia:[255,0,255],
/*  307 */  							olive:[128,128,0],
/*  308 */  							yellow:[255,255,0],
/*  309 */  							orange:[255,165,0],
/*  310 */  							gray:[128,128,128],
/*  311 */  							purple:[128,0,128],
/*  312 */  							green:[0,128,0],
/*  313 */  							red:[255,0,0],
/*  314 */  							pink:[255,192,203],
/*  315 */  							cyan:[0,255,255],
/*  316 */  							transparent:[255,255,255,0]};
/*  317 */  
/*  318 */  
/*  319 */  		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
/*  320 */  		p._onInitTween = function(target, value, tween) {
/*  321 */  			if (!target.nodeType) { //css is only for dom elements
/*  322 */  				return false;
/*  323 */  			}
/*  324 */  			this._target = target;
/*  325 */  			this._tween = tween;
/*  326 */  			this._classData = this._transform = null; //_transform is only used for scaleX/scaleY/x/y/rotation/skewX/skewY tweens and _classData is only used if className is defined - this will be an array of properties that we're tweening related to the class which should be removed from the target.style at the END of the tween when the className is populated so that cascading happens properly.
/*  327 */  			var s = this._style = target.style,
/*  328 */  				cs = _getComputedStyle(target, ""),
/*  329 */  				copy, start, v;
/*  330 */  
/*  331 */  			if (typeof(value) === "string") {
/*  332 */  				copy = s.cssText;
/*  333 */  				start = _getStyles(target, cs);
/*  334 */  				s.cssText = copy + ";" + value;
/*  335 */  				v = _cssDif(start, _getStyles(target));
/*  336 */  				if (!_supportsOpacity && _opacityValExp.test(value)) {
/*  337 */  					val.opacity = parseFloat( RegExp.$1 );
/*  338 */  				}
/*  339 */  				value = v;
/*  340 */  				s.cssText = copy;
/*  341 */  			} else if (value.className) {
/*  342 */  				copy = target.className;
/*  343 */  				start = _getStyles(target, cs);
/*  344 */  				target.className = (value.className.charAt(1) !== "=") ? value.className : (value.className.charAt(0) === "+") ? target.className + " " + value.className.substr(2) : target.className.split(value.className.substr(2)).join("");
/*  345 */  				value = _cssDif(start, _getStyles(target), value, (this._classData = {b:copy, e:target.className, props:[]}));
/*  346 */  				target.className = copy;
/*  347 */  			}
/*  348 */  			this._parseVars(value, target, cs, value.suffixMap || CSSPlugin.suffixMap);
/*  349 */  			return true;
/*  350 */  		}
/*  351 */  
/*  352 */  		//feed a vars object to this function and it will parse through its properties and add PropTweens as necessary. This is split out from the _onInitTween() so that we can recurse if necessary, like "margin" should affect "marginLeft", "marginRight", "marginTop", and "marginBottom".
/*  353 */  		p._parseVars = function(vars, t, cs, map) {
/*  354 */  			var s = this._style,
/*  355 */  				p, v, pt, beg, clr1, clr2, bsfx, esfx, rel, start, copy;
/*  356 */  
/*  357 */  			for (p in vars) {
/*  358 */  
/*  359 */  				v = vars[p];
/*  360 */  
/*  361 */  				if (p === "transform" || p === _transformProp) {
/*  362 */  					this._parseTransform(t, v, cs, map);
/*  363 */  					continue;
/*  364 */  				} else if (_transformMap[p] || p === "transformOrigin") {
/*  365 */  					this._parseTransform(t, vars, cs, map);
/*  366 */  					continue;
/*  367 */  				} else if (p === "alpha" || p === "autoAlpha") { //alpha tweens are opacity tweens
/*  368 */  					p = "opacity";
/*  369 */  				} else if (p === "margin" || p === "padding") {
/*  370 */  					copy = (v + "").split(" ");
/*  371 */  					rel = copy.length;
/*  372 */  					pt = {};
/*  373 */  					pt[p + "Top"] = copy[0];
/*  374 */  					pt[p + "Right"] = (rel > 1) ? copy[1] : copy[0];
/*  375 */  					pt[p + "Bottom"] = (rel === 4) ? copy[2] : copy[0];
/*  376 */  					pt[p + "Left"] = (rel === 4) ? copy[3] : (rel === 2) ? copy[1] : copy[0];
/*  377 */  					this._parseVars(pt, t, cs, map);
/*  378 */  					continue;
/*  379 */  				} else if (p === "backgroundPosition" || p === "backgroundSize") {
/*  380 */  					pt = _parsePosition(v); //end values
/*  381 */  					start = _parsePosition( (beg = _getStyle(t, p, cs)) ); //starting values
/*  382 */  					this._firstPT = pt = {_next:this._firstPT, t:s, p:p, b:beg, f:false, n:"css_" + p, type:3,
/*  383 */  							s:start.ox, //x start
/*  384 */  							c:pt.oxr ? pt.ox : pt.ox - start.ox, //change in x
/*  385 */  							ys:start.oy, //y start
/*  386 */  							yc:pt.oyr ? pt.oy : pt.oy - start.oy, //change in y
/*  387 */  							sfx:pt.oxp ? "%" : "px", //x suffix
/*  388 */  							ysfx:pt.oyp ? "%" : "px", //y suffix
/*  389 */  							r:(!pt.oxp && vars.autoRound !== false)};
/*  390 */  					pt.e = (pt.s + pt.c) + pt.sfx + " " + (pt.ys + pt.yc) + pt.ysfx; //we can't just use v because it could contain relative values, like +=50px which is an illegal final value.
/*  391 */  					continue;
/*  392 */  				} else if (p === "border") {
/*  393 */  					copy = (v + "").split(" ");
/*  394 */  					this._parseVars({borderWidth:copy[0], borderStyle:copy[1] || "none", borderColor:copy[2] || "#000000"}, t, cs, map);
/*  395 */  					continue;
/*  396 */  				} else if (p === "autoRound") {
/*  397 */  					continue;
/*  398 */  				}
/*  399 */  
/*  400 */  				beg = _getStyle(t, p, cs);
/*  401 */  				beg = (beg != null) ? beg + "" : ""; //make sure beginning value is a string. Don't do beg = _getStyle(...) || "" because if _getStyle() returns 0, it will make it "" since 0 is a "falsey" value.
/*  402 */  
/*  403 */  				//Some of these properties are in place in order to conform with the standard PropTweens in TweenPlugins so that overwriting and roundProps occur properly. For example, f and r may seem unnecessary here, but they enable other functionality.
/*  404 */  				//_next:*	next linked list node		[object]
/*  405 */  				//t: 	*	target 						[object]
/*  406 */  				//p:	*	property (camelCase)		[string]
/*  407 */  				//s: 	*	starting value				[number]
/*  408 */  				//c:	*	change value				[number]
/*  409 */  				//f:	* 	is function					[boolean]
/*  410 */  				//n:	*	name (for overwriting)		[string]
/*  411 */  				//sfx:		suffix						[string]
/*  412 */  				//b:		beginning value				[string]
/*  413 */  				//i:		intermediate value			[string]
/*  414 */  				//e: 		ending value				[string]
/*  415 */  				//r:	*	round						[boolean]
/*  416 */  				//type:		0=normal, 1=color, 2=rgba, 3=positional offset (like backgroundPosition or backgroundSize), 4=unsupported opacity (ie), -1=non-tweening prop	[number]
/*  417 */  				this._firstPT = pt = {_next:this._firstPT,
/*  418 */  					  t:s,
/*  419 */  					  p:p,
/*  420 */  					  b:beg,
/*  421 */  					  f:false,
/*  422 */  					  n:"css_" + p,
/*  423 */  					  sfx:"",
/*  424 */  					  r:false,
/*  425 */  					  type:0};
/*  426 */  
/*  427 */  				//if it's an autoAlpha, add a new PropTween for "visibility". We must make sure the "visibility" PropTween comes BEFORE the "opacity" one in order to work around a bug in old versions of IE tht would ignore "visibility" changes if made right after an alpha change. Remember, we add PropTweens in reverse order - that's why we do this here, after creating the original PropTween.
/*  428 */  				if (p === "opacity") if (vars.autoAlpha != null) {
/*  429 */  					if (beg === "1") if (_getStyle(t, "visibility", cs) === "hidden") { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0.
/*  430 */  						beg = pt.b = "0";
/*  431 */  					}
/*  432 */  					this._firstPT = pt._prev = {_next:pt, t:s, p:"visibility", f:false, n:"css_visibility", r:false, type:-1, b:(Number(beg) !== 0) ? "visible" : "hidden", i:"visible", e:(Number(v) === 0) ? "hidden" : "visible"};
/*  433 */  					this._overwriteProps.push("css_visibility");
/*  434 */  				}
/*  435 */  
/*  436 */  				//color values must be split apart into their R, G, B (and sometimes alpha) values and tweened independently.
/*  437 */  				if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (typeof(v) === "string" && !v.indexOf("rgb("))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
/*  438 */  					clr1 = _parseColor(beg);
/*  439 */  					clr2 = _parseColor(v);
/*  440 */  					pt.e = ((clr2.length > 3) ? "rgba" : "rgb") + "(" + clr2.join(",") + ")"; //don't just do pt.e = v because that won't work if the destination color is numeric, like 0xFF0000. We need to parse it.
/*  441 */  					pt.s = Number(clr1[0]);				//red starting value
/*  442 */  					pt.c = Number(clr2[0]) - pt.s;		//red change
/*  443 */  					pt.gs = Number(clr1[1]);			//green starting value
/*  444 */  					pt.gc = Number(clr2[1]) - pt.gs;	//green change
/*  445 */  					pt.bs = Number(clr1[2]);			//blue starting value
/*  446 */  					pt.bc = Number(clr2[2]) - pt.bs;	//blue change
/*  447 */  					if (clr1.length > 3 || clr2.length > 3) { //detect an rgba() value
/*  448 */  						pt.as = (clr1.length < 4) ? 1 : Number(clr1[3]);
/*  449 */  						pt.ac = ((clr2.length < 4) ? 1 : Number(clr2[3])) - pt.as;
/*  450 */  						pt.type = (pt.c || pt.gc || pt.bc || pt.ac) ? 2 : -1; //2 = rgba() tween, -1 = no tween, just set the value at the end
/*  451 */  					} else {
/*  452 */  						pt.type = (pt.c || pt.gc || pt.bc) ? 1 : -1; //1 = color tween, -1 = no tween, just set the value at the end because there's no changes
/*  453 */  					}
/*  454 */  
/*  455 */  				} else {
/*  456 */  
/*  457 */  					bsfx = beg.replace(_suffixExp, ""); //beginning suffix
/*  458 */  
/*  459 */  					if (beg === "" || beg === "auto") {
/*  460 */  						if (p === "width" || p === "height") {
/*  461 */  							start = _getDimension(p, t, cs);
/*  462 */  							bsfx = "px";
/*  463 */  						} else {
/*  464 */  							start = (p !== "opacity") ? 0 : 1;
/*  465 */  							bsfx = "";
/*  466 */  						}
/*  467 */  					} else {
/*  468 */  						start = (beg.indexOf(" ") === -1) ? parseFloat(beg.replace(_NaNExp, "")) : NaN;
/*  469 */  					}
/*  470 */  
/*  471 */  					if (typeof(v) === "string") {
/*  472 */  						rel = (v.charAt(1) === "=");
/*  473 */  						esfx = v.replace(_suffixExp, "");
/*  474 */  						v = (v.indexOf(" ") === -1) ? parseFloat(v.replace(_NaNExp, "")) : NaN;
/*  475 */  					} else {
/*  476 */  						rel = false;
/*  477 */  						esfx = "";
/*  478 */  					}
/*  479 */  
/*  480 */  					if (esfx === "") {
/*  481 */  						esfx = map[p] || bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
/*  482 */  					}
/*  483 */  
/*  484 */  					pt.e = (v || v === 0) ? (rel ? v + start : v) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.
/*  485 */  
/*  486 */  					//if the beginning/ending suffixes don't match, normalize them...
/*  487 */  					if (bsfx !== esfx) if (esfx !== "") if (v || v === 0) if (start || start === 0) {
/*  488 */  						start = _convertToPixels(t, p, start, bsfx);
/*  489 */  						if (esfx === "%") {
/*  490 */  							start /= _convertToPixels(t, p, 100, "%") / 100;
/*  491 */  							if (start > 100) { //extremely rare
/*  492 */  								start = 100;
/*  493 */  							}
/*  494 */  
/*  495 */  						} else if (esfx === "em") {
/*  496 */  							start /= _convertToPixels(t, p, 1, "em");
/*  497 */  
/*  498 */  						//otherwise convert to pixels.
/*  499 */  						} else {
/*  500 */  							v = _convertToPixels(t, p, v, esfx);
/*  501 */  							esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
/*  502 */  						}
/*  503 */  						if (rel) if (v || v === 0) {
/*  504 */  							pt.e = (v + start) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
/*  505 */  						}
/*  506 */  					}
/*  507 */  
/*  508 */  					if ((start || start === 0) && (v || v === 0) && (pt.c = (rel ? v : v - start))) { //faster than isNaN(). Also, we set pt.c (change) here because if it's 0, we'll just treat it like a non-tweening value. can't do (v !== start) because if it's a relative value and the CHANGE is identical to the START, the condition will fail unnecessarily.
/*  509 */  						pt.s = start;
/*  510 */  						pt.sfx = esfx;
/*  511 */  						if (p === "opacity") {
/*  512 */  							if (!_supportsOpacity) {
/*  513 */  								pt.type = 4;
/*  514 */  								pt.p = "filter";
/*  515 */  								pt.b = "alpha(opacity=" + (pt.s * 100) + ")";
/*  516 */  								pt.e = "alpha(opacity=" + ((pt.s + pt.c) * 100) + ")";
/*  517 */  								pt.dup = (vars.autoAlpha != null); //dup = duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
/*  518 */  								this._style.zoom = 1; //helps correct an IE issue.
/*  519 */  							}
/*  520 */  						} else if (vars.autoRound !== false && (esfx === "px" || p === "zIndex")) { //always round zIndex, and as long as autoRound isn't false, round pixel values (that improves performance in browsers typically)
/*  521 */  							pt.r = true;
/*  522 */  						}
/*  523 */  					} else {
/*  524 */  						pt.type = -1;
/*  525 */  						pt.i = pt.e; //intermediate value is typically the same as the end value.
/*  526 */  						pt.s = pt.c = 0;
/*  527 */  					}
/*  528 */  
/*  529 */  				}
/*  530 */  
/*  531 */  				this._overwriteProps.push("css_" + p);
/*  532 */  				if (pt._next) {
/*  533 */  					pt._next._prev = pt;
/*  534 */  				}
/*  535 */  			}
/*  536 */  
/*  537 */  		}
/*  538 */  
/*  539 */  
/*  540 */  		//compares the beginning x, y, scaleX, scaleY, rotation, and skewX properties with the ending ones and adds PropTweens accordingly wherever necessary. We must tween them individually (rather than just tweening the matrix values) so that elgant overwriting can occur, like if one tween is controlling scaleX, scaleY, and rotation and then another one starts mid-tween that is trying to control the scaleX only - this tween should continue tweening scaleY and rotation.
/*  541 */  		p._parseTransform = function(t, v, cs, map) {
/*  542 */  			if (this._transform) { return; } //only need to parse the transform once, and only if the browser supports it.
/*  543 */  
/*  544 */  			var m1 = this._transform = _getTransform(t, cs, true),
/*  545 */  				s = this._style,
/*  546 */  				min = 0.000001,
/*  547 */  				m2, skewY, p, pt, copy, orig;
/*  548 */  
/*  549 */  			if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
/*  550 */  
/*  551 */  				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
/*  552 */  					  scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
/*  553 */  					  x:_parseVal(v.x, m1.x),
/*  554 */  					  y:_parseVal(v.y, m1.y)};
/*  555 */  
/*  556 */  				if (v.shortRotation != null) {
/*  557 */  					m2.rotation = (typeof(v.shortRotation) === "number") ? v.shortRotation * _DEG2RAD : _parseAngle(v.shortRotation, m1.rotation);
/*  558 */  					var dif = (m2.rotation - m1.rotation) % (Math.PI * 2);
/*  559 */  					if (dif !== dif % Math.PI) {
/*  560 */  						dif += Math.PI * ((dif < 0) ? 2 : -2);
/*  561 */  					}
/*  562 */  					m2.rotation = m1.rotation + dif;
/*  563 */  
/*  564 */  				} else {
/*  565 */  					m2.rotation = (v.rotation == null) ? m1.rotation : (typeof(v.rotation) === "number") ? v.rotation * _DEG2RAD : _parseAngle(v.rotation, m1.rotation);
/*  566 */  				}
/*  567 */  				m2.skewX = (v.skewX == null) ? m1.skewX : (typeof(v.skewX) === "number") ? v.skewX * _DEG2RAD : _parseAngle(v.skewX, m1.skewX);
/*  568 */  
/*  569 */  				//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
/*  570 */  				m2.skewY = (v.skewY == null) ? m1.skewY : (typeof(v.skewY) === "number") ? v.skewY * _DEG2RAD : _parseAngle(v.skewY, m1.skewY);
/*  571 */  				if ((skewY = m2.skewY - m1.skewY)) {
/*  572 */  					m2.skewX += skewY
/*  573 */  					m2.rotation += skewY;
/*  574 */  				}
/*  575 */  				//don't allow rotation/skew values to be a SUPER small decimal because when they're translated back to strings for setting the css property, the browser reports them in a funky way, like 1-e7. Of course we could use toFixed() to resolve that issue but that hurts performance quite a bit with all those function calls on every frame, plus it is virtually impossible to discern values that small visually (nobody will notice changing a rotation of 0.0000001 to 0, so the performance improvement is well worth it).
/*  576 */  				if (m2.skewY < min) if (m2.skewY > -min) {
/*  577 */  					m2.skewY = 0;
/*  578 */  				}
/*  579 */  				if (m2.skewX < min) if (m2.skewX > -min) {
/*  580 */  					m2.skewX = 0;
/*  581 */  				}
/*  582 */  				if (m2.rotation < min) if (m2.rotation > -min) {
/*  583 */  					m2.rotation = 0;
/*  584 */  				}
/*  585 */  
/*  586 */  				//if a transformOrigin is defined, handle it here...
/*  587 */  				if ((orig = v.transformOrigin) != null) {
/*  588 */  					if (_transformProp) {
/*  589 */  						p = _transformProp + "Origin";
/*  590 */  						this._firstPT = pt = {_next:this._firstPT, t:s, p:p, s:0, c:0, n:p, f:false, r:false, b:s[p], e:orig, i:orig, type:-1, sfx:""};
/*  591 */  						if (pt._next) {
/*  592 */  							pt._next._prev = pt;
/*  593 */  						}
/*  594 */  
/*  595 */  					//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
/*  596 */  					} else {
/*  597 */  						_parsePosition(orig, m1);
/*  598 */  					}
/*  599 */  				}
/*  600 */  
/*  601 */  			} else if (typeof(v) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
/*  602 */  				copy = s[_transformProp];
/*  603 */  				s[_transformProp] = v;
/*  604 */  				m2 = _getTransform(t, null, false);
/*  605 */  				s[_transformProp] = copy;
/*  606 */  			} else {
/*  607 */  				return;
/*  608 */  			}
/*  609 */  
/*  610 */  			if (!_transformProp) {
/*  611 */  				s.zoom = 1; //helps correct an IE issue.
/*  612 */  			} else if (_reqTransformFix) {
/*  613 */  				s[_transformProp + "Style"] = "preserve-3d"; //corrects a bug in [non-Android] Safari that causes it to skip rendering changes to "top" and "left" that are made on the same frame/render as a transform update. We cannot just check for a Webkit browser because Android devices would evaluate as true, but applying this "fix" actually breaks things in a few Android devices like the Atrix (fun!)
/*  614 */  			}
/*  615 */  
/*  616 */  			for (p in _transformMap) {
/*  617 */  				if (m1[p] !== m2[p]) if (p !== "shortRotation") if (p !== "scale") {
/*  618 */  					this._firstPT = pt = {_next:this._firstPT, t:m1, p:p, s:m1[p], c:m2[p] - m1[p], n:p, f:false, r:false, b:m1[p], e:m2[p], type:0, sfx:0};
/*  619 */  					if (pt._next) {
/*  620 */  						pt._next._prev = pt;
/*  621 */  					}
/*  622 */  					this._overwriteProps.push("css_" + p);
/*  623 */  				}
/*  624 */  			}
/*  625 */  		};
/*  626 */  
/*  627 */  
/*  628 */  		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
/*  629 */  		p.setRatio = function(v) {
/*  630 */  			var pt = this._firstPT,
/*  631 */  				min = 0.000001, val, y;
/*  632 */  
/*  633 */  			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
/*  634 */  			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
/*  635 */  				while (pt) {
/*  636 */  					pt.t[pt.p] = pt.e;
/*  637 */  					if (pt.type === 4) if (pt.s + pt.c === 1) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance.
/*  638 */  						this._style.removeAttribute("filter");
/*  639 */  						if (_getStyle(this._target, "filter")) { //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
/*  640 */  							pt.t[pt.p] = pt.e;
/*  641 */  						}
/*  642 */  					}
/*  643 */  					pt = pt._next;
/*  644 */  				}
/*  645 */  
/*  646 */  			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0)) {
/*  647 */  
/*  648 */  				while (pt) {
/*  649 */  					val = pt.c * v + pt.s;
/*  650 */  					if (pt.r) {
/*  651 */  						val = (val > 0) ? (val + 0.5) >> 0 : (val - 0.5) >> 0;
/*  652 */  					} else if (val < min) if (val > -min) {
/*  653 */  						val = 0;
/*  654 */  					}
/*  655 */  					if (!pt.type) {
/*  656 */  						pt.t[pt.p] = val + pt.sfx;
/*  657 */  					} else if (pt.type === 1) { //rgb()
/*  658 */  						pt.t[pt.p] = "rgb(" + (val >> 0) + ", " + ((pt.gs + (v * pt.gc)) >> 0) + ", " + ((pt.bs + (v * pt.bc)) >> 0) + ")";
/*  659 */  					} else if (pt.type === 2) { //rgba()
/*  660 */  						pt.t[pt.p] = "rgba(" + (val >> 0) + ", " + ((pt.gs + (v * pt.gc)) >> 0) + ", " + ((pt.bs + (v * pt.bc)) >> 0) + ", " + (pt.as + (v * pt.ac)) + ")";
/*  661 */  					} else if (pt.type === -1) { //non-tweening
/*  662 */  						pt.t[pt.p] = pt.i;
/*  663 */  					} else if (pt.type === 3) { //positional property with an x and y, like backgroundPosition or backgroundSize
/*  664 */  						y = pt.ys + v * pt.yc;
/*  665 */  						if (pt.r) {
/*  666 */  							y = (y > 0) ? (y + 0.5) >> 0 : (y - 0.5) >> 0;
/*  667 */  						}
/*  668 */  						pt.t[pt.p] = val + pt.sfx + " " + y + pt.ysfx;
/*  669 */  					} else {
/*  670 */  						if (pt.dup) {
/*  671 */  							pt.t.filter = pt.t.filter || "alpha(opacity=100)"; //works around bug in IE7/8 that prevents changes to "visibility" from being applied propertly if the filter is changed to a different alpha on the same frame.
/*  672 */  						}
/*  673 */  						if (pt.t.filter.indexOf("opacity=") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8)
/*  674 */  							pt.t.filter += " alpha(opacity=" + ((val * 100) >> 0) + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
/*  675 */  						} else {
/*  676 */  							pt.t.filter = pt.t.filter.replace(_opacityExp, "opacity=" + ((val * 100) >> 0)); //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
/*  677 */  						}
/*  678 */  					}
/*  679 */  					pt = pt._next;
/*  680 */  				}
/*  681 */  
/*  682 */  			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
/*  683 */  			} else {
/*  684 */  				while (pt) {
/*  685 */  					pt.t[pt.p] = pt.b;
/*  686 */  					if (pt.type === 4) if (pt.s === 1) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance.
/*  687 */  						this._style.removeAttribute("filter");
/*  688 */  						if (_getStyle(this._target, "filter")) { //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
/*  689 */  							pt.t[pt.p] = pt.b;
/*  690 */  						}
/*  691 */  					}
/*  692 */  					pt = pt._next;
/*  693 */  				}
/*  694 */  			}
/*  695 */  
/*  696 */  			//apply transform values like x, y, scaleX, scaleY, rotation, skewX, or skewY. We do these after looping through all the PropTweens because those are where the changes are made to scaleX/scaleY/rotation/skewX/skewY/x/y.
/*  697 */  			if (this._transform) {
/*  698 */  				pt = this._transform; //to improve speed and reduce size, reuse the pt variable as an alias to the _transform property
/*  699 */  				//if there is no rotation or skew, browsers render the transform faster if we just feed it the list of transforms like translate() skewX() scale(), otherwise defining the matrix() values directly is fastest.
/*  700 */  				if (_transformProp && !pt.rotation && !pt.skewX) {
/*  701 */  					this._style[_transformProp] = ((pt.x || pt.y) ? "translate(" + pt.x + "px," + pt.y + "px) " : "") + ((pt.scaleX !== 1 || pt.scaleY !== 1) ? "scale(" + pt.scaleX + "," + (Math.cos(pt.skewX) * pt.scaleY) + ")" : "") || "translate(0px,0px)"; //we need to default to translate(0px,0px) to work around a Chrome bug that rears its ugly head when the transform is set to "".
/*  702 */  				} else {
/*  703 */  					var ang = _transformProp ? pt.rotation : -pt.rotation,
/*  704 */  						skew = _transformProp ? ang - pt.skewX : ang + pt.skewX,
/*  705 */  						a = Math.cos(ang) * pt.scaleX,
/*  706 */  						b = Math.sin(ang) * pt.scaleX,
/*  707 */  						c = Math.sin(skew) * -pt.scaleY,
/*  708 */  						d = Math.cos(skew) * pt.scaleY,
/*  709 */  						cs;
/*  710 */  					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases for both b and c. The conditional logic here is faster than calling Math.abs().
/*  711 */  					if (b < min) if (b > -min) {
/*  712 */  						b = 0;
/*  713 */  					}
/*  714 */  					if (c < min) if (c > -min) {
/*  715 */  						c = 0;
/*  716 */  					}
/*  717 */  					if (_transformProp) {
/*  718 */  						this._style[_transformProp] = "matrix(" + a + "," + b + "," + c + "," + d + "," + pt.x + "," + pt.y + ")";
/*  719 */  
/*  720 */  					//only for older versions of IE (6-8), we use a filter and marginLeft/marginTop to simulate the transform.
/*  721 */  					} else if ((cs = this._target.currentStyle)) {
/*  722 */  						min = b; //just for swapping the variables an inverting them (reused "min" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
/*  723 */  						b = -c;
/*  724 */  						c = -min;
/*  725 */  						var filters = this._style.filter;
/*  726 */  						this._style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
/*  727 */  						var w = this._target.offsetWidth,
/*  728 */  							h = this._target.offsetHeight,
/*  729 */  							clip = (cs.position !== "absolute"),
/*  730 */  							m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
/*  731 */  							ox = pt.x,
/*  732 */  							oy = pt.y,
/*  733 */  							dx, dy;
/*  734 */  
/*  735 */  						//if transformOrigin is being used, adjust the offset x and y
/*  736 */  						if (pt.ox != null) {
/*  737 */  							dx = ((pt.oxp) ? w * pt.ox * 0.01 : pt.ox) - w / 2;
/*  738 */  							dy = ((pt.oyp) ? h * pt.oy * 0.01 : pt.oy) - h / 2;
/*  739 */  							ox = dx - (dx * a + dy * b) + pt.x;
/*  740 */  							oy = dy - (dx * c + dy * d) + pt.y;
/*  741 */  						}
/*  742 */  
/*  743 */  						if (!clip) {
/*  744 */  							var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
/*  745 */  								i, marg, prop, dif;
/*  746 */  							dx = pt.ieOffsetX || 0;
/*  747 */  							dy = pt.ieOffsetY || 0;
/*  748 */  							pt.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
/*  749 */  							pt.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
/*  750 */  							for (i = 0; i < 4; i++) {
/*  751 */  								prop = _margins[i];
/*  752 */  								marg = cs[prop];
/*  753 */  								//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
/*  754 */  								val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this._target, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
/*  755 */  								//PREVIOUS code: (didn't take into consideration negative right/bottom margins for broken box model in certain versions of IE or concurrent tweens of the margins): this._style[prop] = Math.round( (val - ((i < 2) ? dx - pt.ieOffsetX : dy - pt.ieOffsetY)) ) + "px";
/*  756 */  								if (val !== pt[prop]) {
/*  757 */  									dif = (i < 2) ? -pt.ieOffsetX : -pt.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
/*  758 */  								} else {
/*  759 */  									dif = (i < 2) ? dx - pt.ieOffsetX : dy - pt.ieOffsetY;
/*  760 */  								}
/*  761 */  								this._style[prop] = (pt[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
/*  762 */  							}
/*  763 */  							m += ", sizingMethod='auto expand')";
/*  764 */  						} else {
/*  765 */  							dx = (w / 2),
/*  766 */  							dy = (h / 2);
/*  767 */  							//translate to ensure that transformations occur around the correct origin (default is center).
/*  768 */  							m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
/*  769 */  						}
/*  770 */  
/*  771 */  						if (filters.indexOf("progid:DXImageTransform.Microsoft.Matrix(") !== -1) {
/*  772 */  							this._style.filter = filters.replace(_ieSetMatrixExp, m);
/*  773 */  						} else {
/*  774 */  							this._style.filter = filters + " " + m;
/*  775 */  						}
/*  776 */  
/*  777 */  						//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
/*  778 */  						if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) {
/*  779 */  							this._style.removeAttribute("filter");
/*  780 */  						}
/*  781 */  					}
/*  782 */  				}
/*  783 */  			}
/*  784 */  
/*  785 */  			//if we're adding/changing a class, we should do so at the END of the tween, and drop any of the associated properties that are in the target.style object in order to preserve proper cascading.
/*  786 */  			if (this._classData) {
/*  787 */  				pt = this._classData; //speeds things up slightly and helps minification
/*  788 */  				if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
/*  789 */  					var i = pt.props.length;
/*  790 */  					while (--i > -1) {
/*  791 */  						this._style[pt.props[i]] = "";
/*  792 */  					}
/*  793 */  					this._target.className = pt.e;
/*  794 */  				} else if (this._target.className !== pt.b) {
/*  795 */  					this._target.className = pt.b;
/*  796 */  				}
/*  797 */  			}
/*  798 */  		}
/*  799 */  
/*  800 */  		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
/*  801 */  		p._kill = function(lookup) {
/*  802 */  			var copy = lookup, p;
/*  803 */  			if (lookup.autoAlpha || lookup.alpha) {
/*  804 */  				copy = {};
/*  805 */  				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
/*  806 */  					copy[p] = lookup[p];
/*  807 */  				}
/*  808 */  				copy.opacity = 1;
/*  809 */  				if (copy.autoAlpha) {
/*  810 */  					copy.visibility = 1;
/*  811 */  				}
/*  812 */  			}
/*  813 */  			return TweenPlugin.prototype._kill.call(this, copy);
/*  814 */  		}
/*  815 */  
/*  816 */  
/*  817 */  		TweenPlugin.activate([CSSPlugin]);
/*  818 */  		return CSSPlugin;
/*  819 */  
/*  820 */  	}, true);
/*  821 */  
/*  822 */  }); if (window._gsDefine) { _gsQueue.pop()(); }

/**
 * js/vendor/greensock/TweenLite.js
 */

/*    0 */  /*!
      1      * VERSION: beta 1.28
      2      * DATE: 2012-06-19
      3      * JavaScript (ActionScript 3 and 2 also available)
      4      * UPDATES AND DOCS AT: http://www.greensock.com
      5      *
      6      * Copyright (c) 2008-2012, GreenSock. All rights reserved.
      7      * This work is subject to the terms in http://www.greensock.com/terms_of_use.html or for
      8      * corporate Club GreenSock members, the software agreement that was issued with the corporate
      9      * membership.
     10      *
     11      * @author: Jack Doyle, jack@greensock.com
     12      */
/*   13 */  (function(window) {
/*   14 */  
/*   15 */  		"use strict";
/*   16 */  		var _namespace = function(ns) {
/*   17 */  				var a = ns.split("."),
/*   18 */  					p = window, i;
/*   19 */  				for (i = 0; i < a.length; i++) {
/*   20 */  					p[a[i]] = p = p[a[i]] || {};
/*   21 */  				}
/*   22 */  				return p;
/*   23 */  			},
/*   24 */  			gs = _namespace("com.greensock"),
/*   25 */  			a, i, e, e2, p,
/*   26 */  			_classLookup = {},
/*   27 */  
/*   28 */  			//_DepClass is for defining a dependent class. ns = namespace (leaving off "com.greensock." as that's assumed), dep = an array of namespaces that are required, def = the function that will return the class definition (this function will be passed each dependency in order as soon as they arrive), global = if true, the class is added to the global scope (window) or if requirejs is being used, it will tap into that instead.
/*   29 */  			_DepClass = function(ns, dep, def, global) {
/*   30 */  				this.sc = (_classLookup[ns]) ? _classLookup[ns].sc : []; //subclasses
/*   31 */  				_classLookup[ns] = this;
/*   32 */  				this.gsClass = null;
/*   33 */  				this.def = def;
/*   34 */  				var _dep = dep || [],
/*   35 */  					_classes = [];
/*   36 */  				this.check = function(init) {
/*   37 */  					var i = _dep.length, cnt = 0, cur;
/*   38 */  					while (--i > -1) {
/*   39 */  						if ((cur = _classLookup[_dep[i]] || new _DepClass(_dep[i])).gsClass) {
/*   40 */  							_classes[i] = cur.gsClass;
/*   41 */  						} else {
/*   42 */  							cnt++;
/*   43 */  							if (init) {
/*   44 */  								cur.sc.push(this);
/*   45 */  							}
/*   46 */  						}
/*   47 */  					}
/*   48 */  					if (cnt === 0 && def) {
/*   49 */  						var a = ("com.greensock." + ns).split("."),
/*   50 */  							n = a.pop(),
/*   51 */  							cl = _namespace(a.join("."))[n] = this.gsClass = def.apply(def, _classes);
/*   52 */  
/*   53 */  						//exports to multiple environments
/*   54 */  						if (global) {
/*   55 */  							(window.GreenSockGlobals || window)[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
/*   56 */  							if (typeof(define) === "function" && define.amd){ //AMD
/*   57 */  								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").join("/"), [], function() { return cl; });
/*   58 */  							} else if (typeof(module) !== "undefined" && module.exports){ //node
/*   59 */  								module.exports = cl;
/*   60 */  							}
/*   61 */  						}
/*   62 */  
/*   63 */  						for (i = 0; i < this.sc.length; i++) {
/*   64 */  							this.sc[i].check(false);
/*   65 */  						}
/*   66 */  
/*   67 */  					}
/*   68 */  				};
/*   69 */  				this.check(true);
/*   70 */  			},
/*   71 */  			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
/*   72 */  			_class = gs._class = function(ns, f, g) {
/*   73 */  				new _DepClass(ns, [], function(){ return f; }, g);
/*   74 */  				return f;
/*   75 */  			};
/*   76 */  
/*   77 */  		//used to create _DepClass instances (which basically registers a class that has dependencies). ns = namespace, dep = dependencies (array), f = initialization function which should return the class, g = global (whether or not the class should be added to the global namespace (or if RequireJS is used, it will be defined as a named module instead)
/*   78 */  		window._gsDefine = function(ns, dep, f, g) {
/*   79 */  			return new _DepClass(ns, dep, f, g);
/*   80 */  		};
/*   81 */  
/*   82 */  
/*   83 */  
/*   84 */  /*
     85      * ----------------------------------------------------------------
     86      * Ease
     87      * ----------------------------------------------------------------
     88      */
/*   89 */  		var _baseParams = [0, 0, 1, 1],
/*   90 */  			_blankArray = [],
/*   91 */  			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
/*   92 */  				this._func = func;
/*   93 */  				this._type = type || 0;
/*   94 */  				this._power = power || 0;
/*   95 */  				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
/*   96 */  			}, true);
/*   97 */  
/*   98 */  		p = Ease.prototype;
/*   99 */  		p._calcEnd = false;
/*  100 */  		p.getRatio = function(p) {
/*  101 */  			if (this._func) {
/*  102 */  				this._params[0] = p;
/*  103 */  				return this._func.apply(null, this._params);
/*  104 */  			} else {
/*  105 */  				var t = this._type,
/*  106 */  					pw = this._power,
/*  107 */  					r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
/*  108 */  				if (pw === 1) {
/*  109 */  					r *= r;
/*  110 */  				} else if (pw === 2) {
/*  111 */  					r *= r * r;
/*  112 */  				} else if (pw === 3) {
/*  113 */  					r *= r * r * r;
/*  114 */  				} else if (pw === 4) {
/*  115 */  					r *= r * r * r * r;
/*  116 */  				}
/*  117 */  				return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
/*  118 */  			}
/*  119 */  		};
/*  120 */  
/*  121 */  		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
/*  122 */  		a = ["Linear","Quad","Cubic","Quart","Quint"];
/*  123 */  		i = a.length;
/*  124 */  		while(--i > -1) {
/*  125 */  			e = _class("easing." + a[i], function(){}, true);
/*  126 */  			e2 = _class("easing.Power" + i, function(){}, true);
/*  127 */  			e.easeOut = e2.easeOut = new Ease(null, null, 1, i);
/*  128 */  			e.easeIn = e2.easeIn = new Ease(null, null, 2, i);
/*  129 */  			e.easeInOut = e2.easeInOut = new Ease(null, null, 3, i);
/*  130 */  		}
/*  131 */  		_class("easing.Strong", gs.easing.Power4, true);
/*  132 */  		gs.easing.Linear.easeNone = gs.easing.Linear.easeIn;
/*  133 */  
/*  134 */  
/*  135 */  /*
    136      * ----------------------------------------------------------------
    137      * EventDispatcher
    138      * ----------------------------------------------------------------
    139      */
/*  140 */  		p = _class("events.EventDispatcher", function(target) {
/*  141 */  			this._listeners = {};
/*  142 */  			this._eventTarget = target || this;
/*  143 */  		}).prototype;
/*  144 */  
/*  145 */  		p.addEventListener = function(type, callback, scope, useParam, priority) {
/*  146 */  			priority = priority || 0;
/*  147 */  			var list = this._listeners[type],
/*  148 */  				index = 0,
/*  149 */  				listener, i;
/*  150 */  			if (list == null) {
/*  151 */  				this._listeners[type] = list = [];
/*  152 */  			}
/*  153 */  			i = list.length;
/*  154 */  			while (--i > -1) {
/*  155 */  				listener = list[i];
/*  156 */  				if (listener.c === callback) {
/*  157 */  					list.splice(i, 1);
/*  158 */  				} else if (index === 0 && listener.pr < priority) {
/*  159 */  					index = i + 1;
/*  160 */  				}
/*  161 */  			}
/*  162 */  			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
/*  163 */  		};
/*  164 */  
/*  165 */  		p.removeEventListener = function(type, callback) {
/*  166 */  			var list = this._listeners[type];
/*  167 */  			if (list) {
/*  168 */  				var i = list.length;
/*  169 */  				while (--i > -1) {
/*  170 */  					if (list[i].c === callback) {
/*  171 */  						list.splice(i, 1);
/*  172 */  						return;
/*  173 */  					}
/*  174 */  				}
/*  175 */  			}
/*  176 */  		};
/*  177 */  
/*  178 */  		p.dispatchEvent = function(type) {
/*  179 */  			var list = this._listeners[type];
/*  180 */  			if (list) {
/*  181 */  				var i = list.length, listener,
/*  182 */  					t = this._eventTarget;
/*  183 */  				while (--i > -1) {
/*  184 */  					listener = list[i];
/*  185 */  					if (listener.up) {
/*  186 */  						listener.c.call(listener.s || t, {type:type, target:t});
/*  187 */  					} else {
/*  188 */  						listener.c.call(listener.s || t);
/*  189 */  					}
/*  190 */  				}
/*  191 */  			}
/*  192 */  		};
/*  193 */  
/*  194 */  
/*  195 */  /*
    196      * ----------------------------------------------------------------
    197      * Ticker
    198      * ----------------------------------------------------------------
    199      */
/*  200 */   		var _reqAnimFrame = window.requestAnimationFrame,
/*  201 */  			_cancelAnimFrame = window.cancelAnimationFrame,
/*  202 */  			_getTime = Date.now || function() {return new Date().getTime();};
/*  203 */  
/*  204 */  		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
/*  205 */  		a = ["ms","moz","webkit","o"];
/*  206 */  		i = a.length;
/*  207 */  		while (--i > -1 && !_reqAnimFrame) {
/*  208 */  			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
/*  209 */  			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
/*  210 */  		}
/*  211 */  		if (!_cancelAnimFrame) {
/*  212 */  			_cancelAnimFrame = function(id) {
/*  213 */  				window.clearTimeout(id);
/*  214 */  			}
/*  215 */  		}
/*  216 */  
/*  217 */  		_class("Ticker", function(fps, useRAF) {
/*  218 */  			this.time = 0;
/*  219 */  			this.frame = 0;
/*  220 */  			var _self = this,
/*  221 */  				_startTime = _getTime(),
/*  222 */  				_useRAF = (useRAF !== false),
/*  223 */  				_fps, _req, _id, _gap, _nextTime;
/*  224 */  
/*  225 */  			this.tick = function() {
/*  226 */  				_self.time = (_getTime() - _startTime) / 1000;
/*  227 */  				if (!_fps || _self.time >= _nextTime) {
/*  228 */  					_self.frame++;
/*  229 */  					_nextTime = _self.time + _gap - (_self.time - _nextTime) - 0.0005;
/*  230 */  					if (_nextTime <= _self.time) {
/*  231 */  						_nextTime = _self.time + 0.001;
/*  232 */  					}
/*  233 */  					_self.dispatchEvent("tick");
/*  234 */  				}
/*  235 */  				_id = _req( _self.tick );
/*  236 */  			};
/*  237 */  
/*  238 */  			this.fps = function(value) {
/*  239 */  				if (!arguments.length) {
/*  240 */  					return _fps;
/*  241 */  				}
/*  242 */  				_fps = value;
/*  243 */  				_gap = 1 / (_fps || 60);
/*  244 */  				_nextTime = this.time + _gap;
/*  245 */  				_req = (_fps === 0) ? function(f){} : (!_useRAF || !_reqAnimFrame) ? function(f) { return window.setTimeout( f, (((_nextTime - _self.time) * 1000 + 1) >> 0) || 1);	} : _reqAnimFrame;
/*  246 */  				_cancelAnimFrame(_id);
/*  247 */  				_id = _req( _self.tick );
/*  248 */  			};
/*  249 */  
/*  250 */  			this.useRAF = function(value) {
/*  251 */  				if (!arguments.length) {
/*  252 */  					return _useRAF
/*  253 */  				}
/*  254 */  				_useRAF = value;
/*  255 */  				this.fps(_fps);
/*  256 */  			};
/*  257 */  
/*  258 */  			this.fps(fps);
/*  259 */  		});
/*  260 */  
/*  261 */  		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
/*  262 */  		p.constructor = gs.Ticker;
/*  263 */  
/*  264 */  
/*  265 */  /*
    266      * ----------------------------------------------------------------
    267      * Animation
    268      * ----------------------------------------------------------------
    269      */
/*  270 */  		var Animation = _class("core.Animation", function(duration, vars) {
/*  271 */  				this.vars = vars || {};
/*  272 */  				this._duration = this._totalDuration = duration || 0;
/*  273 */  				this._delay = Number(this.vars.delay) || 0;
/*  274 */  				this._timeScale = 1;
/*  275 */  				this._active = (this.vars.immediateRender == true);
/*  276 */  				this.data = this.vars.data;
/*  277 */  				this._reversed = (this.vars.reversed == true);
/*  278 */  
/*  279 */  				if (!_rootTimeline) {
/*  280 */  					return;
/*  281 */  				}
/*  282 */  
/*  283 */  				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
/*  284 */  				tl.insert(this, tl._time);
/*  285 */  
/*  286 */  				if (this.vars.paused) {
/*  287 */  					this.paused(true);
/*  288 */  				}
/*  289 */  			}),
/*  290 */  			_ticker = Animation.ticker = new gs.Ticker();
/*  291 */  
/*  292 */  		p = Animation.prototype;
/*  293 */  		p._dirty = p._gc = p._initted = p._paused = false;
/*  294 */  		p._totalTime = p._time = 0;
/*  295 */  		p._rawPrevTime = -1;
/*  296 */  		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
/*  297 */  		p._paused = false;
/*  298 */  
/*  299 */  		p.play = function(from, suppressEvents) {
/*  300 */  			if (arguments.length) {
/*  301 */  				this.seek(from, suppressEvents);
/*  302 */  			}
/*  303 */  			this.reversed(false);
/*  304 */  			return this.paused(false);
/*  305 */  		};
/*  306 */  
/*  307 */  		p.pause = function(atTime, suppressEvents) {
/*  308 */  			if (arguments.length) {
/*  309 */  				this.seek(atTime, suppressEvents);
/*  310 */  			}
/*  311 */  			return this.paused(true);
/*  312 */  		};
/*  313 */  
/*  314 */  		p.resume = function(from, suppressEvents) {
/*  315 */  			if (arguments.length) {
/*  316 */  				this.seek(from, suppressEvents);
/*  317 */  			}
/*  318 */  			return this.paused(false);
/*  319 */  		};
/*  320 */  
/*  321 */  		p.seek = function(time, suppressEvents) {
/*  322 */  			return this.totalTime(Number(time), (suppressEvents != false));
/*  323 */  		};
/*  324 */  
/*  325 */  		p.restart = function(includeDelay, suppressEvents) {
/*  326 */  			this.reversed(false);
/*  327 */  			this.paused(false);
/*  328 */  			return this.totalTime((includeDelay) ? -this._delay : 0, (suppressEvents != false));
/*  329 */  		};
/*  330 */  
/*  331 */  		p.reverse = function(from, suppressEvents) {
/*  332 */  			if (arguments.length) {
/*  333 */  				this.seek((from || this.totalDuration()), suppressEvents);
/*  334 */  			}
/*  335 */  			this.reversed(true);
/*  336 */  			return this.paused(false);
/*  337 */  		};
/*  338 */  
/*  339 */  		p.render = function() {
/*  340 */  
/*  341 */  		};
/*  342 */  
/*  343 */  		p.invalidate = function() {
/*  344 */  			return this;
/*  345 */  		};
/*  346 */  
/*  347 */  		p._enabled = function (enabled, ignoreTimeline) {
/*  348 */  			this._gc = !enabled;
/*  349 */  			this._active = (enabled && !this._paused && this._totalTime > 0 && this._totalTime < this._totalDuration);
/*  350 */  			if (ignoreTimeline != true) {
/*  351 */  				if (enabled && this.timeline == null) {
/*  352 */  					this._timeline.insert(this, this._startTime - this._delay);
/*  353 */  				} else if (!enabled && this.timeline != null) {
/*  354 */  					this._timeline._remove(this, true);
/*  355 */  				}
/*  356 */  			}
/*  357 */  			return false;
/*  358 */  		};
/*  359 */  
/*  360 */  
/*  361 */  		p._kill = function(vars, target) {
/*  362 */  			return this._enabled(false, false);
/*  363 */  		};
/*  364 */  
/*  365 */  		p.kill = function(vars, target) {
/*  366 */  			this._kill(vars, target);
/*  367 */  			return this;
/*  368 */  		};
/*  369 */  
/*  370 */  		p._uncache = function(includeSelf) {
/*  371 */  			var tween = includeSelf ? this : this.timeline;
/*  372 */  			while (tween) {
/*  373 */  				tween._dirty = true;
/*  374 */  				tween = tween.timeline;
/*  375 */  			}
/*  376 */  			return this;
/*  377 */  		};
/*  378 */  
/*  379 */  //----Animation getters/setters --------------------------------------------------------
/*  380 */  
/*  381 */  		p.eventCallback = function(type, callback, params, scope) {
/*  382 */  			if (type == null) {
/*  383 */  				return null;
/*  384 */  			} else if (type.substr(0,2) === "on") {
/*  385 */  				if (arguments.length === 1) {
/*  386 */  					return this.vars[type];
/*  387 */  				}
/*  388 */  				if (callback == null) {
/*  389 */  					delete this.vars[type];
/*  390 */  				} else {
/*  391 */  					this.vars[type] = callback;
/*  392 */  					this.vars[type + "Params"] = params;
/*  393 */  					this.vars[type + "Scope"] = scope;
/*  394 */  					if (params) {
/*  395 */  						var i = params.length;
/*  396 */  						while (--i > -1) {
/*  397 */  							if (params[i] === "{self}") {
/*  398 */  								params = this.vars[type + "Params"] = params.concat(); //copying the array avoids situations where the same array is passed to multiple tweens/timelines and {self} doesn't correctly point to each individual instance.
/*  399 */  								params[i] = this;
/*  400 */  							}
/*  401 */  						}
/*  402 */  					}
/*  403 */  				}
/*  404 */  				if (type === "onUpdate") {
/*  405 */  					this._onUpdate = callback;
/*  406 */  				}
/*  407 */  			}
/*  408 */  			return this;
/*  409 */  		}
/*  410 */  
/*  411 */  		p.delay = function(value) {
/*  412 */  			if (!arguments.length) {
/*  413 */  				return this._delay;
/*  414 */  			}
/*  415 */  			if (this._timeline.smoothChildTiming) {
/*  416 */  				this.startTime( this._startTime + value - this._delay );
/*  417 */  			}
/*  418 */  			this._delay = value;
/*  419 */  			return this;
/*  420 */  		};
/*  421 */  
/*  422 */  		p.duration = function(value) {
/*  423 */  			if (!arguments.length) {
/*  424 */  				this._dirty = false;
/*  425 */  				return this._duration;
/*  426 */  			}
/*  427 */  			this._duration = this._totalDuration = value;
/*  428 */  			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
/*  429 */  			if (this._timeline.smoothChildTiming) if (this._active) if (value != 0) {
/*  430 */  				this.totalTime(this._totalTime * (value / this._duration), true);
/*  431 */  			}
/*  432 */  			return this;
/*  433 */  		};
/*  434 */  
/*  435 */  		p.totalDuration = function(value) {
/*  436 */  			this._dirty = false;
/*  437 */  			return (!arguments.length) ? this._totalDuration : this.duration(value);
/*  438 */  		};
/*  439 */  
/*  440 */  		p.time = function(value, suppressEvents) {
/*  441 */  			if (!arguments.length) {
/*  442 */  				return this._time;
/*  443 */  			}
/*  444 */  			if (this._dirty) {
/*  445 */  				this.totalDuration();
/*  446 */  			}
/*  447 */  			if (value > this._duration) {
/*  448 */  				value = this._duration;
/*  449 */  			}
/*  450 */  			return this.totalTime(value, suppressEvents);
/*  451 */  		};
/*  452 */  
/*  453 */  		p.totalTime = function(time, suppressEvents) {
/*  454 */  			if (!arguments.length) {
/*  455 */  				return this._totalTime;
/*  456 */  			}
/*  457 */  			if (this._timeline) {
/*  458 */  				if (time < 0) {
/*  459 */  					time += this.totalDuration();
/*  460 */  				}
/*  461 */  				if (this._timeline.smoothChildTiming) {
/*  462 */  					if (this._dirty) {
/*  463 */  						this.totalDuration();
/*  464 */  					}
/*  465 */  					if (time > this._totalDuration) {
/*  466 */  						time = this._totalDuration;
/*  467 */  					}
/*  468 */  					this._startTime = (this._paused ? this._pauseTime : this._timeline._time) - ((!this._reversed ? time : this._totalDuration - time) / this._timeScale);
/*  469 */  					if (!this._timeline._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the anscestors as dirty too, so skip the function call here.
/*  470 */  						this._uncache(false);
/*  471 */  					}
/*  472 */  					if (!this._timeline._active) {
/*  473 */  						//in case any of the anscestors had completed but should now be enabled...
/*  474 */  						var tl = this._timeline;
/*  475 */  						while (tl._timeline) {
/*  476 */  							tl.totalTime(tl._totalTime, true);
/*  477 */  							tl = tl._timeline;
/*  478 */  						}
/*  479 */  					}
/*  480 */  				}
/*  481 */  				if (this._gc) {
/*  482 */  					this._enabled(true, false);
/*  483 */  				}
/*  484 */  				if (this._totalTime != time) {
/*  485 */  					this.render(time, suppressEvents, false);
/*  486 */  				}
/*  487 */  			}
/*  488 */  			return this;
/*  489 */  		};
/*  490 */  
/*  491 */  		p.startTime = function(value) {
/*  492 */  			if (!arguments.length) {
/*  493 */  				return this._startTime;
/*  494 */  			}
/*  495 */  			if (value != this._startTime) {
/*  496 */  				this._startTime = value;
/*  497 */  				if (this.timeline) if (this.timeline._sortChildren) {
/*  498 */  					this.timeline.insert(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
/*  499 */  				}
/*  500 */  			}
/*  501 */  			return this;
/*  502 */  		};
/*  503 */  
/*  504 */  		p.timeScale = function(value) {
/*  505 */  			if (!arguments.length) {
/*  506 */  				return this._timeScale;
/*  507 */  			}
/*  508 */  			value = value || 0.000001; //can't allow zero because it'll throw the math off
/*  509 */  			if (this._timeline && this._timeline.smoothChildTiming) {
/*  510 */  				var t = (this._pauseTime || this._pauseTime == 0) ? this._pauseTime : this._timeline._totalTime;
/*  511 */  				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
/*  512 */  			}
/*  513 */  			this._timeScale = value;
/*  514 */  			return this._uncache(false);
/*  515 */  		};
/*  516 */  
/*  517 */  		p.reversed = function(value) {
/*  518 */  			if (!arguments.length) {
/*  519 */  				return this._reversed;
/*  520 */  			}
/*  521 */  			if (value != this._reversed) {
/*  522 */  				this._reversed = value;
/*  523 */  				this.totalTime(this._totalTime, true);
/*  524 */  			}
/*  525 */  			return this;
/*  526 */  		};
/*  527 */  
/*  528 */  		p.paused = function(value) {
/*  529 */  			if (!arguments.length) {
/*  530 */  				return this._paused;
/*  531 */  			}
/*  532 */  			if (value != this._paused) if (this._timeline) {
/*  533 */  				if (!value && this._timeline.smoothChildTiming) {
/*  534 */  					this._startTime += this._timeline.rawTime() - this._pauseTime;
/*  535 */  					this._uncache(false);
/*  536 */  				}
/*  537 */  				this._pauseTime = (value) ? this._timeline.rawTime() : null;
/*  538 */  				this._paused = value;
/*  539 */  				this._active = (!this._paused && this._totalTime > 0 && this._totalTime < this._totalDuration);
/*  540 */  			}
/*  541 */  			if (this._gc) if (!value) {
/*  542 */  				this._enabled(true, false);
/*  543 */  			}
/*  544 */  			return this;
/*  545 */  		};
/*  546 */  
/*  547 */  
/*  548 */  /*
    549      * ----------------------------------------------------------------
    550      * SimpleTimeline
    551      * ----------------------------------------------------------------
    552      */
/*  553 */  		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
/*  554 */  			Animation.call(this, 0, vars);
/*  555 */  			this.autoRemoveChildren = this.smoothChildTiming = true;
/*  556 */  		});
/*  557 */  
/*  558 */  		p = SimpleTimeline.prototype = new Animation();
/*  559 */  		p.constructor = SimpleTimeline;
/*  560 */  		p.kill()._gc = false;
/*  561 */  		p._first = p._last = null;
/*  562 */  		p._sortChildren = false;
/*  563 */  
/*  564 */  		p.insert = function(tween, time) {
/*  565 */  			tween._startTime = Number(time || 0) + tween._delay;
/*  566 */  			if (tween._paused) if (this !== tween._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
/*  567 */  				tween._pauseTime = tween._startTime + ((this.rawTime() - tween._startTime) / tween._timeScale);
/*  568 */  			}
/*  569 */  			if (tween.timeline) {
/*  570 */  				tween.timeline._remove(tween, true); //removes from existing timeline so that it can be properly added to this one.
/*  571 */  			}
/*  572 */  			tween.timeline = tween._timeline = this;
/*  573 */  			if (tween._gc) {
/*  574 */  				tween._enabled(true, true);
/*  575 */  			}
/*  576 */  
/*  577 */  			var prevTween = this._last;
/*  578 */  			if (this._sortChildren) {
/*  579 */  				var st = tween._startTime;
/*  580 */  				while (prevTween && prevTween._startTime > st) {
/*  581 */  					prevTween = prevTween._prev;
/*  582 */  				}
/*  583 */  			}
/*  584 */  			if (prevTween) {
/*  585 */  				tween._next = prevTween._next;
/*  586 */  				prevTween._next = tween;
/*  587 */  			} else {
/*  588 */  				tween._next = this._first;
/*  589 */  				this._first = tween;
/*  590 */  			}
/*  591 */  			if (tween._next) {
/*  592 */  				tween._next._prev = tween;
/*  593 */  			} else {
/*  594 */  				this._last = tween;
/*  595 */  			}
/*  596 */  			tween._prev = prevTween;
/*  597 */  
/*  598 */  			if (this._timeline) {
/*  599 */  				this._uncache(true);
/*  600 */  			}
/*  601 */  			return this;
/*  602 */  		};
/*  603 */  
/*  604 */  		p._remove = function(tween, skipDisable) {
/*  605 */  			if (tween.timeline === this) {
/*  606 */  				if (!skipDisable) {
/*  607 */  					tween._enabled(false, true);
/*  608 */  				}
/*  609 */  				tween.timeline = null;
/*  610 */  
/*  611 */  				if (tween._prev) {
/*  612 */  					tween._prev._next = tween._next;
/*  613 */  				} else if (this._first === tween) {
/*  614 */  					this._first = tween._next;
/*  615 */  				}
/*  616 */  				if (tween._next) {
/*  617 */  					tween._next._prev = tween._prev;
/*  618 */  				} else if (this._last === tween) {
/*  619 */  					this._last = tween._prev;
/*  620 */  				}
/*  621 */  
/*  622 */  				if (this._timeline) {
/*  623 */  					this._uncache(true);
/*  624 */  				}
/*  625 */  			}
/*  626 */  			return this;
/*  627 */  		};
/*  628 */  
/*  629 */  		p.render = function(time, suppressEvents, force) {
/*  630 */  			var tween = this._first,
/*  631 */  				next;
/*  632 */  			this._totalTime = this._time = this._rawPrevTime = time;
/*  633 */  			while (tween) {
/*  634 */  				next = tween._next; //record it here because the value could change after rendering...
/*  635 */  				if (tween._active || (time >= tween._startTime && !tween._paused)) {
/*  636 */  					if (!tween._reversed) {
/*  637 */  						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, false);
/*  638 */  					} else {
/*  639 */  						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, false);
/*  640 */  					}
/*  641 */  				}
/*  642 */  				tween = next;
/*  643 */  			}
/*  644 */  		};
/*  645 */  
/*  646 */  		p.rawTime = function() {
/*  647 */  			return this._totalTime;
/*  648 */  		};
/*  649 */  
/*  650 */  
/*  651 */  /*
    652      * ----------------------------------------------------------------
    653      * TweenLite
    654      * ----------------------------------------------------------------
    655      */
/*  656 */  		var TweenLite = _class("TweenLite", function(target, duration, vars) {
/*  657 */  				Animation.call(this, duration, vars);
/*  658 */  
/*  659 */  				if (target == null) {
/*  660 */  					throw "Cannot tween an undefined reference.";
/*  661 */  				}
/*  662 */  				this.target = target;
/*  663 */  
/*  664 */  				this._overwrite = (this.vars.overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(this.vars.overwrite) === "number") ? this.vars.overwrite >> 0 : _overwriteLookup[this.vars.overwrite];
/*  665 */  
/*  666 */  				var jq, i, targ;
/*  667 */  				if ((target instanceof Array || target.jquery) && typeof(target[0]) === "object") {
/*  668 */  					this._targets = target.slice(0); //works for both jQuery and Array instances
/*  669 */  					this._propLookup = [];
/*  670 */  					this._siblings = [];
/*  671 */  					for (i = 0; i < this._targets.length; i++) {
/*  672 */  						targ = this._targets[i];
/*  673 */  						//in case the user is passing in an array of jQuery objects, for example, we need to check one more level and pull things out if necessary...
/*  674 */  						if (targ.jquery) {
/*  675 */  							this._targets.splice(i--, 1);
/*  676 */  							this._targets = this._targets.concat(targ.constructor.makeArray(targ));
/*  677 */  							continue;
/*  678 */  						}
/*  679 */  						this._siblings[i] = _register(targ, this, false);
/*  680 */  						if (this._overwrite === 1) if (this._siblings[i].length > 1) {
/*  681 */  							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
/*  682 */  						}
/*  683 */  					}
/*  684 */  
/*  685 */  				} else {
/*  686 */  					this._propLookup = {};
/*  687 */  					this._siblings = _register(target, this, false);
/*  688 */  					if (this._overwrite === 1) if (this._siblings.length > 1) {
/*  689 */  						_applyOverwrite(target, this, null, 1, this._siblings);
/*  690 */  					}
/*  691 */  				}
/*  692 */  
/*  693 */  				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender != false)) {
/*  694 */  					this.render(-this._delay, false, true);
/*  695 */  				}
/*  696 */  			}, true);
/*  697 */  
/*  698 */  		p = TweenLite.prototype = new Animation();
/*  699 */  		p.constructor = TweenLite;
/*  700 */  		p.kill()._gc = false;
/*  701 */  
/*  702 */  //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------
/*  703 */  
/*  704 */  		p.ratio = 0;
/*  705 */  		p._firstPT = p._targets = p._overwrittenProps = null;
/*  706 */  		p._notifyPluginsOfEnabled = false;
/*  707 */  
/*  708 */  		TweenLite.version = 12;
/*  709 */  		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
/*  710 */  		TweenLite.defaultOverwrite = "auto";
/*  711 */  		TweenLite.ticker = _ticker;
/*  712 */  
/*  713 */  		var _plugins = TweenLite._plugins = {},
/*  714 */  			_tweenLookup = {},
/*  715 */  			_tweenLookupNum = 0,
/*  716 */  			_reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, orientToBezier:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1},
/*  717 */  			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
/*  718 */  			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
/*  719 */  			_rootTimeline = Animation._rootTimeline = new SimpleTimeline();
/*  720 */  
/*  721 */  		_rootTimeline._startTime = _ticker.time;
/*  722 */  		_rootFramesTimeline._startTime = _ticker.frame;
/*  723 */  		_rootTimeline._active = _rootFramesTimeline._active = true;
/*  724 */  
/*  725 */  		Animation._updateRoot = function() {
/*  726 */  				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
/*  727 */  				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
/*  728 */  				if (!(_ticker.frame % 120)) { //dump garbage every 120 frames...
/*  729 */  					var i, a, p;
/*  730 */  					for (p in _tweenLookup) {
/*  731 */  						a = _tweenLookup[p].tweens;
/*  732 */  						i = a.length;
/*  733 */  						while (--i > -1) {
/*  734 */  							if (a[i]._gc) {
/*  735 */  								a.splice(i, 1);
/*  736 */  							}
/*  737 */  						}
/*  738 */  						if (a.length === 0) {
/*  739 */  							delete _tweenLookup[p];
/*  740 */  						}
/*  741 */  					}
/*  742 */  				}
/*  743 */  			};
/*  744 */  
/*  745 */  		_ticker.addEventListener("tick", Animation._updateRoot);
/*  746 */  
/*  747 */  		var _register = function(target, tween, scrub) {
/*  748 */  				var id = target._gsTweenID, a, i;
/*  749 */  				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
/*  750 */  					_tweenLookup[id] = {target:target, tweens:[]};
/*  751 */  				}
/*  752 */  				if (tween) {
/*  753 */  					a = _tweenLookup[id].tweens;
/*  754 */  					a[(i = a.length)] = tween;
/*  755 */  					if (scrub) {
/*  756 */  						while (--i > -1) {
/*  757 */  							if (a[i] === tween) {
/*  758 */  								a.splice(i, 1);
/*  759 */  							}
/*  760 */  						}
/*  761 */  					}
/*  762 */  				}
/*  763 */  				return _tweenLookup[id].tweens;
/*  764 */  			},
/*  765 */  
/*  766 */  			_applyOverwrite = function(target, tween, props, mode, siblings) {
/*  767 */  				var i, changed, curTween;
/*  768 */  				if (mode === 1 || mode >= 4) {
/*  769 */  					var l = siblings.length;
/*  770 */  					for (i = 0; i < l; i++) {
/*  771 */  						if ((curTween = siblings[i]) !== tween) {
/*  772 */  							if (!curTween._gc) if (curTween._enabled(false, false)) {
/*  773 */  								changed = true;
/*  774 */  							}
/*  775 */  						} else if (mode === 5) {
/*  776 */  							break;
/*  777 */  						}
/*  778 */  					}
/*  779 */  					return changed;
/*  780 */  				}
/*  781 */  				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
/*  782 */  				var startTime = tween._startTime + 0.0000000001,
/*  783 */  					overlaps = [],
/*  784 */  					oCount = 0,
/*  785 */  					globalStart;
/*  786 */  				i = siblings.length;
/*  787 */  				while (--i > -1) {
/*  788 */  					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
/*  789 */  						//ignore
/*  790 */  					} else if (curTween._timeline !== tween._timeline) {
/*  791 */  						globalStart = globalStart || _checkOverlap(tween, 0);
/*  792 */  						if (_checkOverlap(curTween, globalStart) === 0) {
/*  793 */  							overlaps[oCount++] = curTween;
/*  794 */  						}
/*  795 */  					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale + 0.0000000001 > startTime) if (!((tween._duration === 0 || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
/*  796 */  						overlaps[oCount++] = curTween;
/*  797 */  					}
/*  798 */  				}
/*  799 */  
/*  800 */  				i = oCount;
/*  801 */  				while (--i > -1) {
/*  802 */  					curTween = overlaps[i];
/*  803 */  					if (mode === 2) if (curTween._kill(props, target)) {
/*  804 */  						changed = true;
/*  805 */  					}
/*  806 */  					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
/*  807 */  						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
/*  808 */  							changed = true;
/*  809 */  						}
/*  810 */  					}
/*  811 */  				}
/*  812 */  				return changed;
/*  813 */  			},
/*  814 */  
/*  815 */  			_checkOverlap = function(tween, reference) {
/*  816 */  				var tl = tween._timeline,
/*  817 */  					ts = tl._timeScale,
/*  818 */  					t = tween._startTime;
/*  819 */  				while (tl._timeline) {
/*  820 */  					t += tl._startTime;
/*  821 */  					ts *= tl._timeScale;
/*  822 */  					if (tl._paused) {
/*  823 */  						return -100;
/*  824 */  					}
/*  825 */  					tl = tl._timeline;
/*  826 */  				}
/*  827 */  				t /= ts;
/*  828 */  				return (t > reference) ? t - reference : (!tween._initted && t - reference < 0.0000000002) ? 0.0000000001 : ((t = t + tween.totalDuration() / tween._timeScale / ts) > reference) ? 0 : t - reference - 0.0000000001;
/*  829 */  			};
/*  830 */  
/*  831 */  
/*  832 */  //---- TweenLite instance methods -----------------------------------------------------------------------------
/*  833 */  
/*  834 */  		p._init = function() {
/*  835 */  			if (this.vars.startAt) {
/*  836 */  				this.vars.startAt.overwrite = 0;
/*  837 */  				this.vars.startAt.immediateRender = true;
/*  838 */  				TweenLite.to(this.target, 0, this.vars.startAt);
/*  839 */  			}
/*  840 */  			var i, initPlugins, pt;
/*  841 */  			if (this.vars.ease instanceof Ease) {
/*  842 */  				this._ease = (this.vars.easeParams instanceof Array) ? this.vars.ease.config.apply(this.vars.ease, this.vars.easeParams) : this.vars.ease;
/*  843 */  			} else if (typeof(this.vars.ease) === "function") {
/*  844 */  				this._ease = new Ease(this.vars.ease, this.vars.easeParams);
/*  845 */  			} else {
/*  846 */  				this._ease = TweenLite.defaultEase;
/*  847 */  			}
/*  848 */  			this._easeType = this._ease._type;
/*  849 */  			this._easePower = this._ease._power;
/*  850 */  			this._firstPT = null;
/*  851 */  
/*  852 */  			if (this._targets) {
/*  853 */  				i = this._targets.length;
/*  854 */  				while (--i > -1) {
/*  855 */  					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (this._overwrittenProps ? this._overwrittenProps[i] : null)) ) {
/*  856 */  						initPlugins = true;
/*  857 */  					}
/*  858 */  				}
/*  859 */  			} else {
/*  860 */  				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, this._overwrittenProps);
/*  861 */  			}
/*  862 */  
/*  863 */  			if (initPlugins) {
/*  864 */  				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
/*  865 */  			}
/*  866 */  			if (this._overwrittenProps) if (this._firstPT == null) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
/*  867 */  				this._enabled(false, false);
/*  868 */  			}
/*  869 */  			if (this.vars.runBackwards) {
/*  870 */  				pt = this._firstPT;
/*  871 */  				while (pt) {
/*  872 */  					pt.s += pt.c;
/*  873 */  					pt.c = -pt.c;
/*  874 */  					pt = pt._next;
/*  875 */  				}
/*  876 */  			}
/*  877 */  			this._onUpdate = this.vars.onUpdate;
/*  878 */  			this._initted = true;
/*  879 */  		};
/*  880 */  
/*  881 */  		p._initProps = function(target, propLookup, siblings, overwrittenProps) {
/*  882 */  			var p, i, initPlugins, plugin, a, pt;
/*  883 */  			if (target == null) {
/*  884 */  				return false;
/*  885 */  			}
/*  886 */  			for (p in this.vars) {
/*  887 */  				if (_reservedProps[p]) {
/*  888 */  					if (p === "onStartParams" || p === "onUpdateParams" || p === "onCompleteParams" || p === "onReverseCompleteParams" || p === "onRepeatParams") if ((a = this.vars[p])) {
/*  889 */  						i = a.length;
/*  890 */  						while (--i > -1) {
/*  891 */  							if (a[i] === "{self}") {
/*  892 */  								a = this.vars[p] = a.concat(); //copy the array in case the user referenced the same array in multiple tweens/timelines (each {self} should be unique)
/*  893 */  								a[i] = this;
/*  894 */  							}
/*  895 */  						}
/*  896 */  					}
/*  897 */  
/*  898 */  				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {
/*  899 */  
/*  900 */  					//t - target 		[object]
/*  901 */  					//p - property 		[string]
/*  902 */  					//s - start			[number]
/*  903 */  					//c - change		[number]
/*  904 */  					//f - isFunction	[boolean]
/*  905 */  					//n - name			[string]
/*  906 */  					//pg - isPlugin 	[boolean]
/*  907 */  					//pr - priority		[number]
/*  908 */  					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:true, n:p, pg:true, pr:plugin._priority};
/*  909 */  					i = plugin._overwriteProps.length;
/*  910 */  					while (--i > -1) {
/*  911 */  						propLookup[plugin._overwriteProps[i]] = this._firstPT;
/*  912 */  					}
/*  913 */  					if (plugin._priority || plugin._onInitAllProps) {
/*  914 */  						initPlugins = true;
/*  915 */  					}
/*  916 */  					if (plugin._onDisable || plugin._onEnable) {
/*  917 */  						this._notifyPluginsOfEnabled = true;
/*  918 */  					}
/*  919 */  
/*  920 */  				} else {
/*  921 */  					this._firstPT = propLookup[p] = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === "function"), n:p, pg:false, pr:0};
/*  922 */  					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
/*  923 */  					pt.c = (typeof(this.vars[p]) === "number") ? this.vars[p] - pt.s : (typeof(this.vars[p]) === "string") ? parseFloat(this.vars[p].split("=").join("")) : 0;
/*  924 */  				}
/*  925 */  				if (pt) if (pt._next) {
/*  926 */  					pt._next._prev = pt;
/*  927 */  				}
/*  928 */  			}
/*  929 */  
/*  930 */  			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
/*  931 */  				return this._initProps(target, propLookup, siblings, overwrittenProps);
/*  932 */  			}
/*  933 */  			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
/*  934 */  				this._kill(propLookup, target);
/*  935 */  				return this._initProps(target, propLookup, siblings, overwrittenProps);
/*  936 */  			}
/*  937 */  			return initPlugins;
/*  938 */  		};
/*  939 */  
/*  940 */  		p.render = function(time, suppressEvents, force) {
/*  941 */  			var prevTime = this._time,
/*  942 */  				isComplete, callback, pt;
/*  943 */  			if (time >= this._duration) {
/*  944 */  				this._totalTime = this._time = this._duration;
/*  945 */  				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
/*  946 */  				if (!this._reversed) {
/*  947 */  					isComplete = true;
/*  948 */  					callback = "onComplete";
/*  949 */  				}
/*  950 */  				if (this._duration === 0) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
/*  951 */  					if (time === 0 || this._rawPrevTime < 0) if (this._rawPrevTime !== time) {
/*  952 */  						force = true;
/*  953 */  					}
/*  954 */  					this._rawPrevTime = time;
/*  955 */  				}
/*  956 */  
/*  957 */  			} else if (time <= 0) {
/*  958 */  				this._totalTime = this._time = 0;
/*  959 */  				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
/*  960 */  				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime > 0)) {
/*  961 */  					callback = "onReverseComplete";
/*  962 */  					isComplete = this._reversed;
/*  963 */  				}
/*  964 */  				if (time < 0) {
/*  965 */  					this._active = false;
/*  966 */  					if (this._duration === 0) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
/*  967 */  						if (this._rawPrevTime >= 0) {
/*  968 */  							force = true;
/*  969 */  						}
/*  970 */  						this._rawPrevTime = time;
/*  971 */  					}
/*  972 */  				} else if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
/*  973 */  					force = true;
/*  974 */  				}
/*  975 */  
/*  976 */  			} else {
/*  977 */  				this._totalTime = this._time = time;
/*  978 */  
/*  979 */  				if (this._easeType) {
/*  980 */  					var r = time / this._duration, type = this._easeType, pow = this._easePower;
/*  981 */  					if (type === 1 || (type === 3 && r >= 0.5)) {
/*  982 */  						r = 1 - r;
/*  983 */  					}
/*  984 */  					if (type === 3) {
/*  985 */  						r *= 2;
/*  986 */  					}
/*  987 */  					if (pow === 1) {
/*  988 */  						r *= r;
/*  989 */  					} else if (pow === 2) {
/*  990 */  						r *= r * r;
/*  991 */  					} else if (pow === 3) {
/*  992 */  						r *= r * r * r;
/*  993 */  					} else if (pow === 4) {
/*  994 */  						r *= r * r * r * r;
/*  995 */  					}
/*  996 */  
/*  997 */  					if (type === 1) {
/*  998 */  						this.ratio = 1 - r;
/*  999 */  					} else if (type === 2) {
/* 1000 */  						this.ratio = r;
/* 1001 */  					} else if (time / this._duration < 0.5) {
/* 1002 */  						this.ratio = r / 2;
/* 1003 */  					} else {
/* 1004 */  						this.ratio = 1 - (r / 2);
/* 1005 */  					}
/* 1006 */  
/* 1007 */  				} else {
/* 1008 */  					this.ratio = this._ease.getRatio(time / this._duration);
/* 1009 */  				}
/* 1010 */  
/* 1011 */  			}
/* 1012 */  
/* 1013 */  			if (this._time === prevTime && !force) {
/* 1014 */  				return;
/* 1015 */  			} else if (!this._initted) {
/* 1016 */  				this._init();
/* 1017 */  				if (!isComplete && this._time) { //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
/* 1018 */  					this.ratio = this._ease.getRatio(this._time / this._duration);
/* 1019 */  				}
/* 1020 */  			}
/* 1021 */  
/* 1022 */  			if (!this._active) if (!this._paused) {
/* 1023 */  				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
/* 1024 */  			}
/* 1025 */  			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0 || this._duration === 0) if (!suppressEvents) {
/* 1026 */  				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
/* 1027 */  			}
/* 1028 */  
/* 1029 */  			pt = this._firstPT;
/* 1030 */  			while (pt) {
/* 1031 */  				if (pt.f) {
/* 1032 */  					pt.t[pt.p](pt.c * this.ratio + pt.s);
/* 1033 */  				} else {
/* 1034 */  					pt.t[pt.p] = pt.c * this.ratio + pt.s;
/* 1035 */  				}
/* 1036 */  				pt = pt._next;
/* 1037 */  			}
/* 1038 */  
/* 1039 */  
/* 1040 */  			if (this._onUpdate) if (!suppressEvents) {
/* 1041 */  				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
/* 1042 */  			}
/* 1043 */  
/* 1044 */  			if (callback) if (!this._gc) { //check _gc because there's a chance that kill() could be called in an onUpdate
/* 1045 */  				if (isComplete) {
/* 1046 */  					if (this._timeline.autoRemoveChildren) {
/* 1047 */  						this._enabled(false, false);
/* 1048 */  					}
/* 1049 */  					this._active = false;
/* 1050 */  				}
/* 1051 */  				if (!suppressEvents) if (this.vars[callback]) {
/* 1052 */  					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
/* 1053 */  				}
/* 1054 */  			}
/* 1055 */  
/* 1056 */  		};
/* 1057 */  
/* 1058 */  		p._kill = function(vars, target) {
/* 1059 */  			if (vars === "all") {
/* 1060 */  				vars = null;
/* 1061 */  			}
/* 1062 */  			if (vars == null) if (target == null || target == this.target) {
/* 1063 */  				return this._enabled(false, false);
/* 1064 */  			}
/* 1065 */  			target = target || this._targets || this.target;
/* 1066 */  			var i, overwrittenProps, p, pt, propLookup, changed, killProps, record;
/* 1067 */  			if ((target instanceof Array || target.jquery) && typeof(target[0]) === "object") {
/* 1068 */  				i = target.length;
/* 1069 */  				while (--i > -1) {
/* 1070 */  					if (this._kill(vars, target[i])) {
/* 1071 */  						changed = true;
/* 1072 */  					}
/* 1073 */  				}
/* 1074 */  			} else {
/* 1075 */  				if (this._targets) {
/* 1076 */  					i = this._targets.length;
/* 1077 */  					while (--i > -1) {
/* 1078 */  						if (target === this._targets[i]) {
/* 1079 */  							propLookup = this._propLookup[i] || {};
/* 1080 */  							this._overwrittenProps = this._overwrittenProps || [];
/* 1081 */  							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
/* 1082 */  							break;
/* 1083 */  						}
/* 1084 */  					}
/* 1085 */  				} else if (target !== this.target) {
/* 1086 */  					return false;
/* 1087 */  				} else {
/* 1088 */  					propLookup = this._propLookup;
/* 1089 */  					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
/* 1090 */  				}
/* 1091 */  
/* 1092 */  				if (propLookup) {
/* 1093 */  					killProps = vars || propLookup;
/* 1094 */  					record = (vars != overwrittenProps && overwrittenProps != "all" && vars != propLookup && (vars == null || vars._tempKill != true)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
/* 1095 */  					for (p in killProps) {
/* 1096 */  						if ((pt = propLookup[p])) {
/* 1097 */  							if (pt.pg && pt.t._kill(killProps)) {
/* 1098 */  								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
/* 1099 */  							}
/* 1100 */  							if (!pt.pg || pt.t._overwriteProps.length === 0) {
/* 1101 */  								if (pt._prev) {
/* 1102 */  									pt._prev._next = pt._next;
/* 1103 */  								} else if (pt === this._firstPT) {
/* 1104 */  									this._firstPT = pt._next;
/* 1105 */  								}
/* 1106 */  								if (pt._next) {
/* 1107 */  									pt._next._prev = pt._prev;
/* 1108 */  								}
/* 1109 */  								pt._next = pt._prev = null;
/* 1110 */  							}
/* 1111 */  							delete propLookup[p];
/* 1112 */  						}
/* 1113 */  						if (record) {
/* 1114 */  							overwrittenProps[p] = 1;
/* 1115 */  						}
/* 1116 */  					}
/* 1117 */  				}
/* 1118 */  			}
/* 1119 */  			return changed;
/* 1120 */  		};
/* 1121 */  
/* 1122 */  		p.invalidate = function() {
/* 1123 */  			if (this._notifyPluginsOfEnabled) {
/* 1124 */  				TweenLite._onPluginEvent("_onDisable", this);
/* 1125 */  			}
/* 1126 */  			this._firstPT = null;
/* 1127 */  			this._overwrittenProps = null;
/* 1128 */  			this._onUpdate = null;
/* 1129 */  			this._initted = this._active = this._notifyPluginsOfEnabled = false;
/* 1130 */  			this._propLookup = (this._targets) ? {} : [];
/* 1131 */  			return this;
/* 1132 */  		};
/* 1133 */  
/* 1134 */  		p._enabled = function(enabled, ignoreTimeline) {
/* 1135 */  			if (enabled && this._gc) {
/* 1136 */  				if (this._targets) {
/* 1137 */  					var i = this._targets.length;
/* 1138 */  					while (--i > -1) {
/* 1139 */  						this._siblings[i] = _register(this._targets[i], this, true);
/* 1140 */  					}
/* 1141 */  				} else {
/* 1142 */  					this._siblings = _register(this.target, this, true);
/* 1143 */  				}
/* 1144 */  			}
/* 1145 */  			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
/* 1146 */  			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
/* 1147 */  				return TweenLite._onPluginEvent(((enabled) ? "_onEnable" : "_onDisable"), this);
/* 1148 */  			}
/* 1149 */  			return false;
/* 1150 */  		};
/* 1151 */  
/* 1152 */  
/* 1153 */  //----TweenLite static methods -----------------------------------------------------
/* 1154 */  
/* 1155 */  		TweenLite.to = function(target, duration, vars) {
/* 1156 */  			return new TweenLite(target, duration, vars);
/* 1157 */  		};
/* 1158 */  
/* 1159 */  		TweenLite.from = function(target, duration, vars) {
/* 1160 */  			vars.runBackwards = true;
/* 1161 */  			if (vars.immediateRender != false) {
/* 1162 */  				vars.immediateRender = true;
/* 1163 */  			}
/* 1164 */  			return new TweenLite(target, duration, vars);
/* 1165 */  		};
/* 1166 */  
/* 1167 */  		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
/* 1168 */  			toVars.startAt = fromVars;
/* 1169 */  			if (fromVars.immediateRender) {
/* 1170 */  				toVars.immediateRender = true;
/* 1171 */  			}
/* 1172 */  			return new TweenLite(target, duration, toVars);
/* 1173 */  		};
/* 1174 */  
/* 1175 */  		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
/* 1176 */  			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, useFrames:useFrames, overwrite:0});
/* 1177 */  		};
/* 1178 */  
/* 1179 */  		TweenLite.set = function(target, vars) {
/* 1180 */  			return new TweenLite(target, 0, vars);
/* 1181 */  		};
/* 1182 */  
/* 1183 */  		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, vars) {
/* 1184 */  			var a = TweenLite.getTweensOf(target),
/* 1185 */  				i = a.length;
/* 1186 */  			while (--i > -1) {
/* 1187 */  				a[i]._kill(vars, target);
/* 1188 */  			}
/* 1189 */  		};
/* 1190 */  
/* 1191 */  		TweenLite.getTweensOf = function(target) {
/* 1192 */  			if (target == null) { return; }
/* 1193 */  			var i, a, j, t;
/* 1194 */  			if ((target instanceof Array || target.jquery) && typeof(target[0]) === "object") {
/* 1195 */  				i = target.length;
/* 1196 */  				a = [];
/* 1197 */  				while (--i > -1) {
/* 1198 */  					a = a.concat(TweenLite.getTweensOf(target[i]));
/* 1199 */  				}
/* 1200 */  				i = a.length;
/* 1201 */  				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
/* 1202 */  				while (--i > -1) {
/* 1203 */  					t = a[i];
/* 1204 */  					j = i;
/* 1205 */  					while (--j > -1) {
/* 1206 */  						if (t === a[j]) {
/* 1207 */  							a.splice(i, 1);
/* 1208 */  						}
/* 1209 */  					}
/* 1210 */  				}
/* 1211 */  			} else {
/* 1212 */  				a = _register(target).concat();
/* 1213 */  				i = a.length;
/* 1214 */  				while (--i > -1) {
/* 1215 */  					if (a[i]._gc) {
/* 1216 */  						a.splice(i, 1);
/* 1217 */  					}
/* 1218 */  				}
/* 1219 */  			}
/* 1220 */  			return a;
/* 1221 */  		};
/* 1222 */  
/* 1223 */  
/* 1224 */  
/* 1225 */  /*
   1226      * ----------------------------------------------------------------
   1227      * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another <script> call before loading plugins which is easy to forget)
   1228      * ----------------------------------------------------------------
   1229      */
/* 1230 */  		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
/* 1231 */  					this._overwriteProps = (props || "").split(",");
/* 1232 */  					this._propName = this._overwriteProps[0];
/* 1233 */  					this._priority = priority || 0;
/* 1234 */  				}, true);
/* 1235 */  
/* 1236 */  		p = TweenPlugin.prototype;
/* 1237 */  		TweenPlugin.version = 12;
/* 1238 */  		TweenPlugin.API = 2;
/* 1239 */  		p._firstPT = null;
/* 1240 */  
/* 1241 */  		p._addTween = function(target, prop, start, end, overwriteProp, round) {
/* 1242 */  			var c;
/* 1243 */  			if (end != null && (c = (typeof(end) === "number" || end.charAt(1) !== "=") ? Number(end) - start : Number(end.split("=").join("")))) {
/* 1244 */  				this._firstPT = {_next:this._firstPT, t:target, p:prop, s:start, c:c, f:(typeof(target[prop]) === "function"), n:overwriteProp || prop, r:round};
/* 1245 */  				if (this._firstPT._next) {
/* 1246 */  					this._firstPT._next._prev = this._firstPT;
/* 1247 */  				}
/* 1248 */  			}
/* 1249 */  		}
/* 1250 */  
/* 1251 */  		p.setRatio = function(v) {
/* 1252 */  			var pt = this._firstPT,
/* 1253 */  				val;
/* 1254 */  			while (pt) {
/* 1255 */  				val = pt.c * v + pt.s;
/* 1256 */  				if (pt.r) {
/* 1257 */  					val = (val + ((val > 0) ? 0.5 : -0.5)) >> 0; //about 4x faster than Math.round()
/* 1258 */  				}
/* 1259 */  				if (pt.f) {
/* 1260 */  					pt.t[pt.p](val);
/* 1261 */  				} else {
/* 1262 */  					pt.t[pt.p] = val;
/* 1263 */  				}
/* 1264 */  				pt = pt._next;
/* 1265 */  			}
/* 1266 */  		}
/* 1267 */  
/* 1268 */  		p._kill = function(lookup) {
/* 1269 */  			if (lookup[this._propName] != null) {
/* 1270 */  				this._overwriteProps = [];
/* 1271 */  			} else {
/* 1272 */  				var i = this._overwriteProps.length;
/* 1273 */  				while (--i > -1) {
/* 1274 */  					if (lookup[this._overwriteProps[i]] != null) {
/* 1275 */  						this._overwriteProps.splice(i, 1);
/* 1276 */  					}
/* 1277 */  				}
/* 1278 */  			}
/* 1279 */  			var pt = this._firstPT;
/* 1280 */  			while (pt) {
/* 1281 */  				if (lookup[pt.n] != null) {
/* 1282 */  					if (pt._next) {
/* 1283 */  						pt._next._prev = pt._prev;
/* 1284 */  					}
/* 1285 */  					if (pt._prev) {
/* 1286 */  						pt._prev._next = pt._next;
/* 1287 */  						pt._prev = null;
/* 1288 */  					} else if (this._firstPT === pt) {
/* 1289 */  						this._firstPT = pt._next;
/* 1290 */  					}
/* 1291 */  				}
/* 1292 */  				pt = pt._next;
/* 1293 */  			}
/* 1294 */  			return false;
/* 1295 */  		}
/* 1296 */  
/* 1297 */  		p._roundProps = function(lookup, value) {
/* 1298 */  			var pt = this._firstPT;
/* 1299 */  			while (pt) {
/* 1300 */  				if (lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ])) { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
/* 1301 */  					pt.r = value;
/* 1302 */  				}
/* 1303 */  				pt = pt._next;
/* 1304 */  			}
/* 1305 */  		}
/* 1306 */  
/* 1307 */  		TweenLite._onPluginEvent = function(type, tween) {
/* 1308 */  			var pt = tween._firstPT,
/* 1309 */  				changed;
/* 1310 */  			if (type === "_onInitAllProps") {
/* 1311 */  				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
/* 1312 */  				var pt2, first, last, next;
/* 1313 */  				while (pt) {
/* 1314 */  					next = pt._next;
/* 1315 */  					pt2 = first;
/* 1316 */  					while (pt2 && pt2.pr > pt.pr) {
/* 1317 */  						pt2 = pt2._next;
/* 1318 */  					}
/* 1319 */  					if ((pt._prev = pt2 ? pt2._prev : last)) {
/* 1320 */  						pt._prev._next = pt;
/* 1321 */  					} else {
/* 1322 */  						first = pt;
/* 1323 */  					}
/* 1324 */  					if ((pt._next = pt2)) {
/* 1325 */  						pt2._prev = pt;
/* 1326 */  					} else {
/* 1327 */  						last = pt;
/* 1328 */  					}
/* 1329 */  					pt = next;
/* 1330 */  				}
/* 1331 */  				pt = tween._firstPT = first;
/* 1332 */  			}
/* 1333 */  			while (pt) {
/* 1334 */  				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
/* 1335 */  					changed = true;
/* 1336 */  				}
/* 1337 */  				pt = pt._next;
/* 1338 */  			}
/* 1339 */  			return changed;
/* 1340 */  		}
/* 1341 */  
/* 1342 */  		TweenPlugin.activate = function(plugins) {
/* 1343 */  			var i = plugins.length;
/* 1344 */  			while (--i > -1) {
/* 1345 */  				if (plugins[i].API === TweenPlugin.API) {
/* 1346 */  					TweenLite._plugins[(new plugins[i]())._propName] = plugins[i];
/* 1347 */  				}
/* 1348 */  			}
/* 1349 */  			return true;
/* 1350 */  		}
/* 1351 */  
/* 1352 */  
/* 1353 */  
/* 1354 */  		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
/* 1355 */  		if ((a = window._gsQueue)) {
/* 1356 */  			for (i = 0; i < a.length; i++) {
/* 1357 */  				a[i]();
/* 1358 */  			}
/* 1359 */  			for (p in _classLookup) {
/* 1360 */  				if (!_classLookup[p].def) {
/* 1361 */  					console.log("Warning: TweenLite encountered missing dependency: com.greensock."+p);
/* 1362 */  				}
/* 1363 */  			}
/* 1364 */  		}
/* 1365 */  
/* 1366 */  
/* 1367 */  })(window);

/**
 * js/vendor/zepto.js
 */

/*    0 */  /* Zepto v1.0rc1 - polyfill zepto event detect fx ajax form touch - zeptojs.com/license */
/*    1 */  ;(function(undefined){
/*    2 */    if (String.prototype.trim === undefined) // fix for iOS 3.2
/*    3 */      String.prototype.trim = function(){ return this.replace(/^\s+/, '').replace(/\s+$/, '') }
/*    4 */  
/*    5 */    // For iOS 3.x
/*    6 */    // from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce
/*    7 */    if (Array.prototype.reduce === undefined)
/*    8 */      Array.prototype.reduce = function(fun){
/*    9 */        if(this === void 0 || this === null) throw new TypeError()
/*   10 */        var t = Object(this), len = t.length >>> 0, k = 0, accumulator
/*   11 */        if(typeof fun != 'function') throw new TypeError()
/*   12 */        if(len == 0 && arguments.length == 1) throw new TypeError()
/*   13 */  
/*   14 */        if(arguments.length >= 2)
/*   15 */         accumulator = arguments[1]
/*   16 */        else
/*   17 */          do{
/*   18 */            if(k in t){
/*   19 */              accumulator = t[k++]
/*   20 */              break
/*   21 */            }
/*   22 */            if(++k >= len) throw new TypeError()
/*   23 */          } while (true)
/*   24 */  
/*   25 */        while (k < len){
/*   26 */          if(k in t) accumulator = fun.call(undefined, accumulator, t[k], k, t)
/*   27 */          k++
/*   28 */        }
/*   29 */        return accumulator
/*   30 */      }
/*   31 */  
/*   32 */  })()
/*   33 */  var Zepto = (function() {
/*   34 */    var undefined, key, $, classList, emptyArray = [], slice = emptyArray.slice,
/*   35 */      document = window.document,
/*   36 */      elementDisplay = {}, classCache = {},
/*   37 */      getComputedStyle = document.defaultView.getComputedStyle,
/*   38 */      cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },
/*   39 */      fragmentRE = /^\s*<(\w+|!)[^>]*>/,
/*   40 */  
/*   41 */      // Used by `$.zepto.init` to wrap elements, text/comment nodes, document,
/*   42 */      // and document fragment node types.
/*   43 */      elementTypes = [1, 3, 8, 9, 11],
/*   44 */  
/*   45 */      adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],
/*   46 */      table = document.createElement('table'),
/*   47 */      tableRow = document.createElement('tr'),
/*   48 */      containers = {
/*   49 */        'tr': document.createElement('tbody'),
/*   50 */        'tbody': table, 'thead': table, 'tfoot': table,
/*   51 */        'td': tableRow, 'th': tableRow,
/*   52 */        '*': document.createElement('div')
/*   53 */      },
/*   54 */      readyRE = /complete|loaded|interactive/,
/*   55 */      classSelectorRE = /^\.([\w-]+)$/,
/*   56 */      idSelectorRE = /^#([\w-]+)$/,
/*   57 */      tagSelectorRE = /^[\w-]+$/,
/*   58 */      toString = ({}).toString,
/*   59 */      zepto = {},
/*   60 */      camelize, uniq,
/*   61 */      tempParent = document.createElement('div')
/*   62 */  
/*   63 */    zepto.matches = function(element, selector) {
/*   64 */      if (!element || element.nodeType !== 1) return false
/*   65 */      var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector ||
/*   66 */                            element.oMatchesSelector || element.matchesSelector
/*   67 */      if (matchesSelector) return matchesSelector.call(element, selector)
/*   68 */      // fall back to performing a selector:
/*   69 */      var match, parent = element.parentNode, temp = !parent
/*   70 */      if (temp) (parent = tempParent).appendChild(element)
/*   71 */      match = ~zepto.qsa(parent, selector).indexOf(element)
/*   72 */      temp && tempParent.removeChild(element)
/*   73 */      return match
/*   74 */    }
/*   75 */  
/*   76 */    function isFunction(value) { return toString.call(value) == "[object Function]" }
/*   77 */    function isObject(value) { return value instanceof Object }
/*   78 */    function isPlainObject(value) {
/*   79 */      var key, ctor
/*   80 */      if (toString.call(value) !== "[object Object]") return false
/*   81 */      ctor = (isFunction(value.constructor) && value.constructor.prototype)
/*   82 */      if (!ctor || !hasOwnProperty.call(ctor, 'isPrototypeOf')) return false
/*   83 */      for (key in value);
/*   84 */      return key === undefined || hasOwnProperty.call(value, key)
/*   85 */    }
/*   86 */    function isArray(value) { return value instanceof Array }
/*   87 */    function likeArray(obj) { return typeof obj.length == 'number' }
/*   88 */  
/*   89 */    function compact(array) { return array.filter(function(item){ return item !== undefined && item !== null }) }
/*   90 */    function flatten(array) { return array.length > 0 ? [].concat.apply([], array) : array }
/*   91 */    camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }
/*   92 */    function dasherize(str) {
/*   93 */      return str.replace(/::/g, '/')
/*   94 */             .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
/*   95 */             .replace(/([a-z\d])([A-Z])/g, '$1_$2')
/*   96 */             .replace(/_/g, '-')
/*   97 */             .toLowerCase()
/*   98 */    }
/*   99 */    uniq = function(array){ return array.filter(function(item, idx){ return array.indexOf(item) == idx }) }
/*  100 */  
/*  101 */    function classRE(name) {
/*  102 */      return name in classCache ?
/*  103 */        classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'))
/*  104 */    }
/*  105 */  
/*  106 */    function maybeAddPx(name, value) {
/*  107 */      return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
/*  108 */    }
/*  109 */  
/*  110 */    function defaultDisplay(nodeName) {
/*  111 */      var element, display
/*  112 */      if (!elementDisplay[nodeName]) {
/*  113 */        element = document.createElement(nodeName)
/*  114 */        document.body.appendChild(element)
/*  115 */        display = getComputedStyle(element, '').getPropertyValue("display")
/*  116 */        element.parentNode.removeChild(element)
/*  117 */        display == "none" && (display = "block")
/*  118 */        elementDisplay[nodeName] = display
/*  119 */      }
/*  120 */      return elementDisplay[nodeName]
/*  121 */    }
/*  122 */  
/*  123 */    // `$.zepto.fragment` takes a html string and an optional tag name
/*  124 */    // to generate DOM nodes nodes from the given html string.
/*  125 */    // The generated DOM nodes are returned as an array.
/*  126 */    // This function can be overriden in plugins for example to make
/*  127 */    // it compatible with browsers that don't support the DOM fully.
/*  128 */    zepto.fragment = function(html, name) {
/*  129 */      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1
/*  130 */      if (!(name in containers)) name = '*'
/*  131 */      var container = containers[name]
/*  132 */      container.innerHTML = '' + html
/*  133 */      return $.each(slice.call(container.childNodes), function(){
/*  134 */        container.removeChild(this)
/*  135 */      })
/*  136 */    }
/*  137 */  
/*  138 */    // `$.zepto.Z` swaps out the prototype of the given `dom` array
/*  139 */    // of nodes with `$.fn` and thus supplying all the Zepto functions
/*  140 */    // to the array. Note that `__proto__` is not supported on Internet
/*  141 */    // Explorer. This method can be overriden in plugins.
/*  142 */    zepto.Z = function(dom, selector) {
/*  143 */      dom = dom || []
/*  144 */      dom.__proto__ = arguments.callee.prototype
/*  145 */      dom.selector = selector || ''
/*  146 */      return dom
/*  147 */    }
/*  148 */  
/*  149 */    // `$.zepto.isZ` should return `true` if the given object is a Zepto
/*  150 */    // collection. This method can be overriden in plugins.
/*  151 */    zepto.isZ = function(object) {
/*  152 */      return object instanceof zepto.Z
/*  153 */    }
/*  154 */  
/*  155 */    // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
/*  156 */    // takes a CSS selector and an optional context (and handles various
/*  157 */    // special cases).
/*  158 */    // This method can be overriden in plugins.
/*  159 */    zepto.init = function(selector, context) {
/*  160 */      // If nothing given, return an empty Zepto collection
/*  161 */      if (!selector) return zepto.Z()
/*  162 */      // If a function is given, call it when the DOM is ready
/*  163 */      else if (isFunction(selector)) return $(document).ready(selector)
/*  164 */      // If a Zepto collection is given, juts return it
/*  165 */      else if (zepto.isZ(selector)) return selector
/*  166 */      else {
/*  167 */        var dom
/*  168 */        // normalize array if an array of nodes is given
/*  169 */        if (isArray(selector)) dom = compact(selector)
/*  170 */        // if a JavaScript object is given, return a copy of it
/*  171 */        // this is a somewhat peculiar option, but supported by
/*  172 */        // jQuery so we'll do it, too
/*  173 */        else if (isPlainObject(selector))
/*  174 */          dom = [$.extend({}, selector)], selector = null
/*  175 */        // wrap stuff like `document` or `window`
/*  176 */        else if (elementTypes.indexOf(selector.nodeType) >= 0 || selector === window)
/*  177 */          dom = [selector], selector = null
/*  178 */        // If it's a html fragment, create nodes from it
/*  179 */        else if (fragmentRE.test(selector))
/*  180 */          dom = zepto.fragment(selector.trim(), RegExp.$1), selector = null
/*  181 */        // If there's a context, create a collection on that context first, and select
/*  182 */        // nodes from there
/*  183 */        else if (context !== undefined) return $(context).find(selector)
/*  184 */        // And last but no least, if it's a CSS selector, use it to select nodes.
/*  185 */        else dom = zepto.qsa(document, selector)
/*  186 */        // create a new Zepto collection from the nodes found
/*  187 */        return zepto.Z(dom, selector)
/*  188 */      }
/*  189 */    }
/*  190 */  
/*  191 */    // `$` will be the base `Zepto` object. When calling this
/*  192 */    // function just call `$.zepto.init, whichs makes the implementation
/*  193 */    // details of selecting nodes and creating Zepto collections
/*  194 */    // patchable in plugins.
/*  195 */    $ = function(selector, context){
/*  196 */      return zepto.init(selector, context)
/*  197 */    }
/*  198 */  
/*  199 */    // Copy all but undefined properties from one or more
/*  200 */    // objects to the `target` object.
/*  201 */    $.extend = function(target){
/*  202 */      slice.call(arguments, 1).forEach(function(source) {
/*  203 */        for (key in source)
/*  204 */          if (source[key] !== undefined)
/*  205 */            target[key] = source[key]
/*  206 */      })
/*  207 */      return target
/*  208 */    }
/*  209 */  
/*  210 */    // `$.zepto.qsa` is Zepto's CSS selector implementation which
/*  211 */    // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
/*  212 */    // This method can be overriden in plugins.
/*  213 */    zepto.qsa = function(element, selector){
/*  214 */      var found
/*  215 */      return (element === document && idSelectorRE.test(selector)) ?
/*  216 */        ( (found = element.getElementById(RegExp.$1)) ? [found] : emptyArray ) :
/*  217 */        (element.nodeType !== 1 && element.nodeType !== 9) ? emptyArray :
/*  218 */        slice.call(
/*  219 */          classSelectorRE.test(selector) ? element.getElementsByClassName(RegExp.$1) :
/*  220 */          tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :
/*  221 */          element.querySelectorAll(selector)
/*  222 */        )
/*  223 */    }
/*  224 */  
/*  225 */    function filtered(nodes, selector) {
/*  226 */      return selector === undefined ? $(nodes) : $(nodes).filter(selector)
/*  227 */    }
/*  228 */  
/*  229 */    function funcArg(context, arg, idx, payload) {
/*  230 */     return isFunction(arg) ? arg.call(context, idx, payload) : arg
/*  231 */    }
/*  232 */  
/*  233 */    $.isFunction = isFunction
/*  234 */    $.isObject = isObject
/*  235 */    $.isArray = isArray
/*  236 */    $.isPlainObject = isPlainObject
/*  237 */  
/*  238 */    $.inArray = function(elem, array, i){
/*  239 */      return emptyArray.indexOf.call(array, elem, i)
/*  240 */    }
/*  241 */  
/*  242 */    $.trim = function(str) { return str.trim() }
/*  243 */  
/*  244 */    // plugin compatibility
/*  245 */    $.uuid = 0
/*  246 */  
/*  247 */    $.map = function(elements, callback){
/*  248 */      var value, values = [], i, key
/*  249 */      if (likeArray(elements))
/*  250 */        for (i = 0; i < elements.length; i++) {
/*  251 */          value = callback(elements[i], i)
/*  252 */          if (value != null) values.push(value)
/*  253 */        }
/*  254 */      else
/*  255 */        for (key in elements) {
/*  256 */          value = callback(elements[key], key)
/*  257 */          if (value != null) values.push(value)
/*  258 */        }
/*  259 */      return flatten(values)
/*  260 */    }
/*  261 */  
/*  262 */    $.each = function(elements, callback){
/*  263 */      var i, key
/*  264 */      if (likeArray(elements)) {
/*  265 */        for (i = 0; i < elements.length; i++)
/*  266 */          if (callback.call(elements[i], i, elements[i]) === false) return elements
/*  267 */      } else {
/*  268 */        for (key in elements)
/*  269 */          if (callback.call(elements[key], key, elements[key]) === false) return elements
/*  270 */      }
/*  271 */  
/*  272 */      return elements
/*  273 */    }
/*  274 */  
/*  275 */    // Define methods that will be available on all
/*  276 */    // Zepto collections
/*  277 */    $.fn = {
/*  278 */      // Because a collection acts like an array
/*  279 */      // copy over these useful array functions.
/*  280 */      forEach: emptyArray.forEach,
/*  281 */      reduce: emptyArray.reduce,
/*  282 */      push: emptyArray.push,
/*  283 */      indexOf: emptyArray.indexOf,
/*  284 */      concat: emptyArray.concat,
/*  285 */  
/*  286 */      // `map` and `slice` in the jQuery API work differently
/*  287 */      // from their array counterparts
/*  288 */      map: function(fn){
/*  289 */        return $.map(this, function(el, i){ return fn.call(el, i, el) })
/*  290 */      },
/*  291 */      slice: function(){
/*  292 */        return $(slice.apply(this, arguments))
/*  293 */      },
/*  294 */  
/*  295 */      ready: function(callback){
/*  296 */        if (readyRE.test(document.readyState)) callback($)
/*  297 */        else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)
/*  298 */        return this
/*  299 */      },
/*  300 */      get: function(idx){
/*  301 */        return idx === undefined ? slice.call(this) : this[idx]
/*  302 */      },
/*  303 */      toArray: function(){ return this.get() },
/*  304 */      size: function(){
/*  305 */        return this.length
/*  306 */      },
/*  307 */      remove: function(){
/*  308 */        return this.each(function(){
/*  309 */          if (this.parentNode != null)
/*  310 */            this.parentNode.removeChild(this)
/*  311 */        })
/*  312 */      },
/*  313 */      each: function(callback){
/*  314 */        this.forEach(function(el, idx){ callback.call(el, idx, el) })
/*  315 */        return this
/*  316 */      },
/*  317 */      filter: function(selector){
/*  318 */        return $([].filter.call(this, function(element){
/*  319 */          return zepto.matches(element, selector)
/*  320 */        }))
/*  321 */      },
/*  322 */      add: function(selector,context){
/*  323 */        return $(uniq(this.concat($(selector,context))))
/*  324 */      },
/*  325 */      is: function(selector){
/*  326 */        return this.length > 0 && zepto.matches(this[0], selector)
/*  327 */      },
/*  328 */      not: function(selector){
/*  329 */        var nodes=[]
/*  330 */        if (isFunction(selector) && selector.call !== undefined)
/*  331 */          this.each(function(idx){
/*  332 */            if (!selector.call(this,idx)) nodes.push(this)
/*  333 */          })
/*  334 */        else {
/*  335 */          var excludes = typeof selector == 'string' ? this.filter(selector) :
/*  336 */            (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
/*  337 */          this.forEach(function(el){
/*  338 */            if (excludes.indexOf(el) < 0) nodes.push(el)
/*  339 */          })
/*  340 */        }
/*  341 */        return $(nodes)
/*  342 */      },
/*  343 */      eq: function(idx){
/*  344 */        return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
/*  345 */      },
/*  346 */      first: function(){
/*  347 */        var el = this[0]
/*  348 */        return el && !isObject(el) ? el : $(el)
/*  349 */      },
/*  350 */      last: function(){
/*  351 */        var el = this[this.length - 1]
/*  352 */        return el && !isObject(el) ? el : $(el)
/*  353 */      },
/*  354 */      find: function(selector){
/*  355 */        var result
/*  356 */        if (this.length == 1) result = zepto.qsa(this[0], selector)
/*  357 */        else result = this.map(function(){ return zepto.qsa(this, selector) })
/*  358 */        return $(result)
/*  359 */      },
/*  360 */      closest: function(selector, context){
/*  361 */        var node = this[0]
/*  362 */        while (node && !zepto.matches(node, selector))
/*  363 */          node = node !== context && node !== document && node.parentNode
/*  364 */        return $(node)
/*  365 */      },
/*  366 */      parents: function(selector){
/*  367 */        var ancestors = [], nodes = this
/*  368 */        while (nodes.length > 0)
/*  369 */          nodes = $.map(nodes, function(node){
/*  370 */            if ((node = node.parentNode) && node !== document && ancestors.indexOf(node) < 0) {
/*  371 */              ancestors.push(node)
/*  372 */              return node
/*  373 */            }
/*  374 */          })
/*  375 */        return filtered(ancestors, selector)
/*  376 */      },
/*  377 */      parent: function(selector){
/*  378 */        return filtered(uniq(this.pluck('parentNode')), selector)
/*  379 */      },
/*  380 */      children: function(selector){
/*  381 */        return filtered(this.map(function(){ return slice.call(this.children) }), selector)
/*  382 */      },
/*  383 */      siblings: function(selector){
/*  384 */        return filtered(this.map(function(i, el){
/*  385 */          return slice.call(el.parentNode.children).filter(function(child){ return child!==el })
/*  386 */        }), selector)
/*  387 */      },
/*  388 */      empty: function(){
/*  389 */        return this.each(function(){ this.innerHTML = '' })
/*  390 */      },
/*  391 */      // `pluck` is borrowed from Prototype.js
/*  392 */      pluck: function(property){
/*  393 */        return this.map(function(){ return this[property] })
/*  394 */      },
/*  395 */      show: function(){
/*  396 */        return this.each(function(){
/*  397 */          this.style.display == "none" && (this.style.display = null)
/*  398 */          if (getComputedStyle(this, '').getPropertyValue("display") == "none")
/*  399 */            this.style.display = defaultDisplay(this.nodeName)
/*  400 */        })
/*  401 */      },
/*  402 */      replaceWith: function(newContent){
/*  403 */        return this.before(newContent).remove()
/*  404 */      },
/*  405 */      wrap: function(newContent){
/*  406 */        return this.each(function(){
/*  407 */          $(this).wrapAll($(newContent)[0].cloneNode(false))
/*  408 */        })
/*  409 */      },
/*  410 */      wrapAll: function(newContent){
/*  411 */        if (this[0]) {
/*  412 */          $(this[0]).before(newContent = $(newContent))
/*  413 */          newContent.append(this)
/*  414 */        }
/*  415 */        return this
/*  416 */      },
/*  417 */      unwrap: function(){
/*  418 */        this.parent().each(function(){
/*  419 */          $(this).replaceWith($(this).children())
/*  420 */        })
/*  421 */        return this
/*  422 */      },
/*  423 */      clone: function(){
/*  424 */        return $(this.map(function(){ return this.cloneNode(true) }))
/*  425 */      },
/*  426 */      hide: function(){
/*  427 */        return this.css("display", "none")
/*  428 */      },
/*  429 */      toggle: function(setting){
/*  430 */        return (setting === undefined ? this.css("display") == "none" : setting) ? this.show() : this.hide()
/*  431 */      },
/*  432 */      prev: function(){ return $(this.pluck('previousElementSibling')) },
/*  433 */      next: function(){ return $(this.pluck('nextElementSibling')) },
/*  434 */      html: function(html){
/*  435 */        return html === undefined ?
/*  436 */          (this.length > 0 ? this[0].innerHTML : null) :
/*  437 */          this.each(function(idx){
/*  438 */            var originHtml = this.innerHTML
/*  439 */            $(this).empty().append( funcArg(this, html, idx, originHtml) )
/*  440 */          })
/*  441 */      },
/*  442 */      text: function(text){
/*  443 */        return text === undefined ?
/*  444 */          (this.length > 0 ? this[0].textContent : null) :
/*  445 */          this.each(function(){ this.textContent = text })
/*  446 */      },
/*  447 */      attr: function(name, value){
/*  448 */        var result
/*  449 */        return (typeof name == 'string' && value === undefined) ?
/*  450 */          (this.length == 0 || this[0].nodeType !== 1 ? undefined :
/*  451 */            (name == 'value' && this[0].nodeName == 'INPUT') ? this.val() :
/*  452 */            (!(result = this[0].getAttribute(name)) && name in this[0]) ? this[0][name] : result
/*  453 */          ) :
/*  454 */          this.each(function(idx){
/*  455 */            if (this.nodeType !== 1) return
/*  456 */            if (isObject(name)) for (key in name) this.setAttribute(key, name[key])
/*  457 */            else this.setAttribute(name, funcArg(this, value, idx, this.getAttribute(name)))
/*  458 */          })
/*  459 */      },
/*  460 */      removeAttr: function(name){
/*  461 */        return this.each(function(){ if (this.nodeType === 1) this.removeAttribute(name) })
/*  462 */      },
/*  463 */      prop: function(name, value){
/*  464 */        return (value === undefined) ?
/*  465 */          (this[0] ? this[0][name] : undefined) :
/*  466 */          this.each(function(idx){
/*  467 */            this[name] = funcArg(this, value, idx, this[name])
/*  468 */          })
/*  469 */      },
/*  470 */      data: function(name, value){
/*  471 */        var data = this.attr('data-' + dasherize(name), value)
/*  472 */        return data !== null ? data : undefined
/*  473 */      },
/*  474 */      val: function(value){
/*  475 */        return (value === undefined) ?
/*  476 */          (this.length > 0 ? this[0].value : undefined) :
/*  477 */          this.each(function(idx){
/*  478 */            this.value = funcArg(this, value, idx, this.value)
/*  479 */          })
/*  480 */      },
/*  481 */      offset: function(){
/*  482 */        if (this.length==0) return null
/*  483 */        var obj = this[0].getBoundingClientRect()
/*  484 */        return {
/*  485 */          left: obj.left + window.pageXOffset,
/*  486 */          top: obj.top + window.pageYOffset,
/*  487 */          width: obj.width,
/*  488 */          height: obj.height
/*  489 */        }
/*  490 */      },
/*  491 */      css: function(property, value){
/*  492 */        if (value === undefined && typeof property == 'string')
/*  493 */          return (
/*  494 */            this.length == 0
/*  495 */              ? undefined
/*  496 */              : this[0].style[camelize(property)] || getComputedStyle(this[0], '').getPropertyValue(property))
/*  497 */  
/*  498 */        var css = ''
/*  499 */        for (key in property)
/*  500 */          if(typeof property[key] == 'string' && property[key] == '')
/*  501 */            this.each(function(){ this.style.removeProperty(dasherize(key)) })
/*  502 */          else
/*  503 */            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
/*  504 */  
/*  505 */        if (typeof property == 'string')
/*  506 */          if (value == '')
/*  507 */            this.each(function(){ this.style.removeProperty(dasherize(property)) })
/*  508 */          else
/*  509 */            css = dasherize(property) + ":" + maybeAddPx(property, value)
/*  510 */  
/*  511 */        return this.each(function(){ this.style.cssText += ';' + css })
/*  512 */      },
/*  513 */      index: function(element){
/*  514 */        return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
/*  515 */      },
/*  516 */      hasClass: function(name){
/*  517 */        if (this.length < 1) return false
/*  518 */        else return classRE(name).test(this[0].className)
/*  519 */      },
/*  520 */      addClass: function(name){
/*  521 */        return this.each(function(idx){
/*  522 */          classList = []
/*  523 */          var cls = this.className, newName = funcArg(this, name, idx, cls)
/*  524 */          newName.split(/\s+/g).forEach(function(klass){
/*  525 */            if (!$(this).hasClass(klass)) classList.push(klass)
/*  526 */          }, this)
/*  527 */          classList.length && (this.className += (cls ? " " : "") + classList.join(" "))
/*  528 */        })
/*  529 */      },
/*  530 */      removeClass: function(name){
/*  531 */        return this.each(function(idx){
/*  532 */          if (name === undefined)
/*  533 */            return this.className = ''
/*  534 */          classList = this.className
/*  535 */          funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
/*  536 */            classList = classList.replace(classRE(klass), " ")
/*  537 */          })
/*  538 */          this.className = classList.trim()
/*  539 */        })
/*  540 */      },
/*  541 */      toggleClass: function(name, when){
/*  542 */        return this.each(function(idx){
/*  543 */          var newName = funcArg(this, name, idx, this.className)
/*  544 */          ;(when === undefined ? !$(this).hasClass(newName) : when) ?
/*  545 */            $(this).addClass(newName) : $(this).removeClass(newName)
/*  546 */        })
/*  547 */      }
/*  548 */    }
/*  549 */  
/*  550 */    // Generate the `width` and `height` functions
/*  551 */    ;['width', 'height'].forEach(function(dimension){
/*  552 */      $.fn[dimension] = function(value){
/*  553 */        var offset, Dimension = dimension.replace(/./, function(m){ return m[0].toUpperCase() })
/*  554 */        if (value === undefined) return this[0] == window ? window['inner' + Dimension] :
/*  555 */          this[0] == document ? document.documentElement['offset' + Dimension] :
/*  556 */          (offset = this.offset()) && offset[dimension]
/*  557 */        else return this.each(function(idx){
/*  558 */          var el = $(this)
/*  559 */          el.css(dimension, funcArg(this, value, idx, el[dimension]()))
/*  560 */        })
/*  561 */      }
/*  562 */    })
/*  563 */  
/*  564 */    function insert(operator, target, node) {
/*  565 */      var parent = (operator % 2) ? target : target.parentNode
/*  566 */      parent ? parent.insertBefore(node,
/*  567 */        !operator ? target.nextSibling :      // after
/*  568 */        operator == 1 ? parent.firstChild :   // prepend
/*  569 */        operator == 2 ? target :              // before
/*  570 */        null) :                               // append
/*  571 */        $(node).remove()
/*  572 */    }
/*  573 */  
/*  574 */    function traverseNode(node, fun) {
/*  575 */      fun(node)
/*  576 */      for (var key in node.childNodes) traverseNode(node.childNodes[key], fun)
/*  577 */    }
/*  578 */  
/*  579 */    // Generate the `after`, `prepend`, `before`, `append`,
/*  580 */    // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
/*  581 */    adjacencyOperators.forEach(function(key, operator) {
/*  582 */      $.fn[key] = function(){
/*  583 */        // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
/*  584 */        var nodes = $.map(arguments, function(n){ return isObject(n) ? n : zepto.fragment(n) })
/*  585 */        if (nodes.length < 1) return this
/*  586 */        var size = this.length, copyByClone = size > 1, inReverse = operator < 2
/*  587 */  
/*  588 */        return this.each(function(index, target){
/*  589 */          for (var i = 0; i < nodes.length; i++) {
/*  590 */            var node = nodes[inReverse ? nodes.length-i-1 : i]
/*  591 */            traverseNode(node, function(node){
/*  592 */              if (node.nodeName != null && node.nodeName.toUpperCase() === 'SCRIPT' && (!node.type || node.type === 'text/javascript'))
/*  593 */                window['eval'].call(window, node.innerHTML)
/*  594 */            })
/*  595 */            if (copyByClone && index < size - 1) node = node.cloneNode(true)
/*  596 */            insert(operator, target, node)
/*  597 */          }
/*  598 */        })
/*  599 */      }
/*  600 */  
/*  601 */      $.fn[(operator % 2) ? key+'To' : 'insert'+(operator ? 'Before' : 'After')] = function(html){
/*  602 */        $(html)[key](this)
/*  603 */        return this
/*  604 */      }
/*  605 */    })
/*  606 */  
/*  607 */    zepto.Z.prototype = $.fn
/*  608 */  
/*  609 */    // Export internal API functions in the `$.zepto` namespace
/*  610 */    zepto.camelize = camelize
/*  611 */    zepto.uniq = uniq
/*  612 */    $.zepto = zepto
/*  613 */  
/*  614 */    return $
/*  615 */  })()
/*  616 */  
/*  617 */  // If `$` is not yet defined, point it to `Zepto`
/*  618 */  window.Zepto = Zepto
/*  619 */  '$' in window || (window.$ = Zepto)
/*  620 */  ;(function($){
/*  621 */    var $$ = $.zepto.qsa, handlers = {}, _zid = 1, specialEvents={}
/*  622 */  
/*  623 */    specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'
/*  624 */  
/*  625 */    function zid(element) {
/*  626 */      return element._zid || (element._zid = _zid++)
/*  627 */    }
/*  628 */    function findHandlers(element, event, fn, selector) {
/*  629 */      event = parse(event)
/*  630 */      if (event.ns) var matcher = matcherFor(event.ns)
/*  631 */      return (handlers[zid(element)] || []).filter(function(handler) {
/*  632 */        return handler
/*  633 */          && (!event.e  || handler.e == event.e)
/*  634 */          && (!event.ns || matcher.test(handler.ns))
/*  635 */          && (!fn       || zid(handler.fn) === zid(fn))
/*  636 */          && (!selector || handler.sel == selector)
/*  637 */      })
/*  638 */    }
/*  639 */    function parse(event) {
/*  640 */      var parts = ('' + event).split('.')
/*  641 */      return {e: parts[0], ns: parts.slice(1).sort().join(' ')}
/*  642 */    }
/*  643 */    function matcherFor(ns) {
/*  644 */      return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
/*  645 */    }
/*  646 */  
/*  647 */    function eachEvent(events, fn, iterator){
/*  648 */      if ($.isObject(events)) $.each(events, iterator)
/*  649 */      else events.split(/\s/).forEach(function(type){ iterator(type, fn) })
/*  650 */    }
/*  651 */  
/*  652 */    function add(element, events, fn, selector, getDelegate, capture){
/*  653 */      capture = !!capture
/*  654 */      var id = zid(element), set = (handlers[id] || (handlers[id] = []))
/*  655 */      eachEvent(events, fn, function(event, fn){
/*  656 */        var delegate = getDelegate && getDelegate(fn, event),
/*  657 */          callback = delegate || fn
/*  658 */        var proxyfn = function (event) {
/*  659 */          var result = callback.apply(element, [event].concat(event.data))
/*  660 */          if (result === false) event.preventDefault()
/*  661 */          return result
/*  662 */        }
/*  663 */        var handler = $.extend(parse(event), {fn: fn, proxy: proxyfn, sel: selector, del: delegate, i: set.length})
/*  664 */        set.push(handler)
/*  665 */        element.addEventListener(handler.e, proxyfn, capture)
/*  666 */      })
/*  667 */    }
/*  668 */    function remove(element, events, fn, selector){
/*  669 */      var id = zid(element)
/*  670 */      eachEvent(events || '', fn, function(event, fn){
/*  671 */        findHandlers(element, event, fn, selector).forEach(function(handler){
/*  672 */          delete handlers[id][handler.i]
/*  673 */          element.removeEventListener(handler.e, handler.proxy, false)
/*  674 */        })
/*  675 */      })
/*  676 */    }
/*  677 */  
/*  678 */    $.event = { add: add, remove: remove }
/*  679 */  
/*  680 */    $.proxy = function(fn, context) {
/*  681 */      if ($.isFunction(fn)) {
/*  682 */        var proxyFn = function(){ return fn.apply(context, arguments) }
/*  683 */        proxyFn._zid = zid(fn)
/*  684 */        return proxyFn
/*  685 */      } else if (typeof context == 'string') {
/*  686 */        return $.proxy(fn[context], fn)
/*  687 */      } else {
/*  688 */        throw new TypeError("expected function")
/*  689 */      }
/*  690 */    }
/*  691 */  
/*  692 */    $.fn.bind = function(event, callback){
/*  693 */      return this.each(function(){
/*  694 */        add(this, event, callback)
/*  695 */      })
/*  696 */    }
/*  697 */    $.fn.unbind = function(event, callback){
/*  698 */      return this.each(function(){
/*  699 */        remove(this, event, callback)
/*  700 */      })
/*  701 */    }
/*  702 */    $.fn.one = function(event, callback){
/*  703 */      return this.each(function(i, element){
/*  704 */        add(this, event, callback, null, function(fn, type){
/*  705 */          return function(){
/*  706 */            var result = fn.apply(element, arguments)
/*  707 */            remove(element, type, fn)
/*  708 */            return result
/*  709 */          }
/*  710 */        })
/*  711 */      })
/*  712 */    }
/*  713 */  
/*  714 */    var returnTrue = function(){return true},
/*  715 */        returnFalse = function(){return false},
/*  716 */        eventMethods = {
/*  717 */          preventDefault: 'isDefaultPrevented',
/*  718 */          stopImmediatePropagation: 'isImmediatePropagationStopped',
/*  719 */          stopPropagation: 'isPropagationStopped'
/*  720 */        }
/*  721 */    function createProxy(event) {
/*  722 */      var proxy = $.extend({originalEvent: event}, event)
/*  723 */      $.each(eventMethods, function(name, predicate) {
/*  724 */        proxy[name] = function(){
/*  725 */          this[predicate] = returnTrue
/*  726 */          return event[name].apply(event, arguments)
/*  727 */        }
/*  728 */        proxy[predicate] = returnFalse
/*  729 */      })
/*  730 */      return proxy
/*  731 */    }
/*  732 */  
/*  733 */    // emulates the 'defaultPrevented' property for browsers that have none
/*  734 */    function fix(event) {
/*  735 */      if (!('defaultPrevented' in event)) {
/*  736 */        event.defaultPrevented = false
/*  737 */        var prevent = event.preventDefault
/*  738 */        event.preventDefault = function() {
/*  739 */          this.defaultPrevented = true
/*  740 */          prevent.call(this)
/*  741 */        }
/*  742 */      }
/*  743 */    }
/*  744 */  
/*  745 */    $.fn.delegate = function(selector, event, callback){
/*  746 */      var capture = false
/*  747 */      if(event == 'blur' || event == 'focus'){
/*  748 */        if($.iswebkit)
/*  749 */          event = event == 'blur' ? 'focusout' : event == 'focus' ? 'focusin' : event
/*  750 */        else
/*  751 */          capture = true
/*  752 */      }
/*  753 */  
/*  754 */      return this.each(function(i, element){
/*  755 */        add(element, event, callback, selector, function(fn){
/*  756 */          return function(e){
/*  757 */            var evt, match = $(e.target).closest(selector, element).get(0)
/*  758 */            if (match) {
/*  759 */              evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})
/*  760 */              return fn.apply(match, [evt].concat([].slice.call(arguments, 1)))
/*  761 */            }
/*  762 */          }
/*  763 */        }, capture)
/*  764 */      })
/*  765 */    }
/*  766 */    $.fn.undelegate = function(selector, event, callback){
/*  767 */      return this.each(function(){
/*  768 */        remove(this, event, callback, selector)
/*  769 */      })
/*  770 */    }
/*  771 */  
/*  772 */    $.fn.live = function(event, callback){
/*  773 */      $(document.body).delegate(this.selector, event, callback)
/*  774 */      return this
/*  775 */    }
/*  776 */    $.fn.die = function(event, callback){
/*  777 */      $(document.body).undelegate(this.selector, event, callback)
/*  778 */      return this
/*  779 */    }
/*  780 */  
/*  781 */    $.fn.on = function(event, selector, callback){
/*  782 */      return selector == undefined || $.isFunction(selector) ?
/*  783 */        this.bind(event, selector) : this.delegate(selector, event, callback)
/*  784 */    }
/*  785 */    $.fn.off = function(event, selector, callback){
/*  786 */      return selector == undefined || $.isFunction(selector) ?
/*  787 */        this.unbind(event, selector) : this.undelegate(selector, event, callback)
/*  788 */    }
/*  789 */  
/*  790 */    $.fn.trigger = function(event, data){
/*  791 */      if (typeof event == 'string') event = $.Event(event)
/*  792 */      fix(event)
/*  793 */      event.data = data
/*  794 */      return this.each(function(){
/*  795 */        // items in the collection might not be DOM elements
/*  796 */        // (todo: possibly support events on plain old objects)
/*  797 */        if('dispatchEvent' in this) this.dispatchEvent(event)
/*  798 */      })
/*  799 */    }
/*  800 */  
/*  801 */    // triggers event handlers on current element just as if an event occurred,
/*  802 */    // doesn't trigger an actual event, doesn't bubble
/*  803 */    $.fn.triggerHandler = function(event, data){
/*  804 */      var e, result
/*  805 */      this.each(function(i, element){
/*  806 */        e = createProxy(typeof event == 'string' ? $.Event(event) : event)
/*  807 */        e.data = data
/*  808 */        e.target = element
/*  809 */        $.each(findHandlers(element, event.type || event), function(i, handler){
/*  810 */          result = handler.proxy(e)
/*  811 */          if (e.isImmediatePropagationStopped()) return false
/*  812 */        })
/*  813 */      })
/*  814 */      return result
/*  815 */    }
/*  816 */  
/*  817 */    // shortcut methods for `.bind(event, fn)` for each event type
/*  818 */    ;('focusin focusout load resize scroll unload click dblclick '+
/*  819 */    'mousedown mouseup mousemove mouseover mouseout '+
/*  820 */    'change select keydown keypress keyup error').split(' ').forEach(function(event) {
/*  821 */      $.fn[event] = function(callback){ return this.bind(event, callback) }
/*  822 */    })
/*  823 */  
/*  824 */    ;['focus', 'blur'].forEach(function(name) {
/*  825 */      $.fn[name] = function(callback) {
/*  826 */        if (callback) this.bind(name, callback)
/*  827 */        else if (this.length) try { this.get(0)[name]() } catch(e){}
/*  828 */        return this
/*  829 */      }
/*  830 */    })
/*  831 */  
/*  832 */    $.Event = function(type, props) {
/*  833 */      var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true
/*  834 */      if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])
/*  835 */      event.initEvent(type, bubbles, true, null, null, null, null, null, null, null, null, null, null, null, null)
/*  836 */      return event
/*  837 */    }
/*  838 */  
/*  839 */  })(Zepto)
/*  840 */  ;(function($){
/*  841 */    function detect(ua){
/*  842 */      var os = this.os = {}, browser = this.browser = {},
/*  843 */        webkit = ua.match(/WebKit\/([\d.]+)/),
/*  844 */        android = ua.match(/(Android)\s+([\d.]+)/),
/*  845 */        ipad = ua.match(/(iPad).*OS\s([\d_]+)/),
/*  846 */        iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/),
/*  847 */        webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
/*  848 */        touchpad = webos && ua.match(/TouchPad/),
/*  849 */        kindle = ua.match(/Kindle\/([\d.]+)/),
/*  850 */        silk = ua.match(/Silk\/([\d._]+)/),
/*  851 */        blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/)
/*  852 */  
/*  853 */      // todo clean this up with a better OS/browser
/*  854 */      // separation. we need to discern between multiple
/*  855 */      // browsers on android, and decide if kindle fire in
/*  856 */      // silk mode is android or not
/*  857 */  
/*  858 */      if (browser.webkit = !!webkit) browser.version = webkit[1]
/*  859 */  
/*  860 */      if (android) os.android = true, os.version = android[2]
/*  861 */      if (iphone) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.')
/*  862 */      if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.')
/*  863 */      if (webos) os.webos = true, os.version = webos[2]
/*  864 */      if (touchpad) os.touchpad = true
/*  865 */      if (blackberry) os.blackberry = true, os.version = blackberry[2]
/*  866 */      if (kindle) os.kindle = true, os.version = kindle[1]
/*  867 */      if (silk) browser.silk = true, browser.version = silk[1]
/*  868 */      if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true
/*  869 */    }
/*  870 */  
/*  871 */    detect.call($, navigator.userAgent)
/*  872 */    // make available to unit tests
/*  873 */    $.__detect = detect
/*  874 */  
/*  875 */  })(Zepto)
/*  876 */  ;(function($, undefined){
/*  877 */    var prefix = '', eventPrefix, endEventName, endAnimationName,
/*  878 */      vendors = { Webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' },
/*  879 */      document = window.document, testEl = document.createElement('div'),
/*  880 */      supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
/*  881 */      clearProperties = {}
/*  882 */  
/*  883 */    function downcase(str) { return str.toLowerCase() }
/*  884 */    function normalizeEvent(name) { return eventPrefix ? eventPrefix + name : downcase(name) }
/*  885 */  
/*  886 */    $.each(vendors, function(vendor, event){
/*  887 */      if (testEl.style[vendor + 'TransitionProperty'] !== undefined) {
/*  888 */        prefix = '-' + downcase(vendor) + '-'
/*  889 */        eventPrefix = event
/*  890 */        return false
/*  891 */      }
/*  892 */    })
/*  893 */  
/*  894 */    clearProperties[prefix + 'transition-property'] =
/*  895 */    clearProperties[prefix + 'transition-duration'] =
/*  896 */    clearProperties[prefix + 'transition-timing-function'] =
/*  897 */    clearProperties[prefix + 'animation-name'] =
/*  898 */    clearProperties[prefix + 'animation-duration'] = ''
/*  899 */  
/*  900 */    $.fx = {
/*  901 */      off: (eventPrefix === undefined && testEl.style.transitionProperty === undefined),
/*  902 */      cssPrefix: prefix,
/*  903 */      transitionEnd: normalizeEvent('TransitionEnd'),
/*  904 */      animationEnd: normalizeEvent('AnimationEnd')
/*  905 */    }
/*  906 */  
/*  907 */    $.fn.animate = function(properties, duration, ease, callback){
/*  908 */      if ($.isObject(duration))
/*  909 */        ease = duration.easing, callback = duration.complete, duration = duration.duration
/*  910 */      if (duration) duration = duration / 1000
/*  911 */      return this.anim(properties, duration, ease, callback)
/*  912 */    }
/*  913 */  
/*  914 */    $.fn.anim = function(properties, duration, ease, callback){
/*  915 */      var transforms, cssProperties = {}, key, that = this, wrappedCallback, endEvent = $.fx.transitionEnd
/*  916 */      if (duration === undefined) duration = 0.4
/*  917 */      if ($.fx.off) duration = 0
/*  918 */  
/*  919 */      if (typeof properties == 'string') {
/*  920 */        // keyframe animation
/*  921 */        cssProperties[prefix + 'animation-name'] = properties
/*  922 */        cssProperties[prefix + 'animation-duration'] = duration + 's'
/*  923 */        endEvent = $.fx.animationEnd
/*  924 */      } else {
/*  925 */        // CSS transitions
/*  926 */        for (key in properties)
/*  927 */          if (supportedTransforms.test(key)) {
/*  928 */            transforms || (transforms = [])
/*  929 */            transforms.push(key + '(' + properties[key] + ')')
/*  930 */          }
/*  931 */          else cssProperties[key] = properties[key]
/*  932 */  
/*  933 */        if (transforms) cssProperties[prefix + 'transform'] = transforms.join(' ')
/*  934 */        if (!$.fx.off && typeof properties === 'object') {
/*  935 */          cssProperties[prefix + 'transition-property'] = Object.keys(properties).join(', ')
/*  936 */          cssProperties[prefix + 'transition-duration'] = duration + 's'
/*  937 */          cssProperties[prefix + 'transition-timing-function'] = (ease || 'linear')
/*  938 */        }
/*  939 */      }
/*  940 */  
/*  941 */      wrappedCallback = function(event){
/*  942 */        if (typeof event !== 'undefined') {
/*  943 */          if (event.target !== event.currentTarget) return // makes sure the event didn't bubble from "below"
/*  944 */          $(event.target).unbind(endEvent, arguments.callee)
/*  945 */        }
/*  946 */        $(this).css(clearProperties)
/*  947 */        callback && callback.call(this)
/*  948 */      }
/*  949 */      if (duration > 0) this.bind(endEvent, wrappedCallback)
/*  950 */  
/*  951 */      setTimeout(function() {
/*  952 */        that.css(cssProperties)
/*  953 */        if (duration <= 0) setTimeout(function() {
/*  954 */          that.each(function(){ wrappedCallback.call(this) })
/*  955 */        }, 0)
/*  956 */      }, 0)
/*  957 */  
/*  958 */      return this
/*  959 */    }
/*  960 */  
/*  961 */    testEl = null
/*  962 */  })(Zepto)
/*  963 */  ;(function($){
/*  964 */    var jsonpID = 0,
/*  965 */        isObject = $.isObject,
/*  966 */        document = window.document,
/*  967 */        key,
/*  968 */        name,
/*  969 */        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
/*  970 */        scriptTypeRE = /^(?:text|application)\/javascript/i,
/*  971 */        xmlTypeRE = /^(?:text|application)\/xml/i,
/*  972 */        jsonType = 'application/json',
/*  973 */        htmlType = 'text/html',
/*  974 */        blankRE = /^\s*$/
/*  975 */  
/*  976 */    // trigger a custom event and return false if it was cancelled
/*  977 */    function triggerAndReturn(context, eventName, data) {
/*  978 */      var event = $.Event(eventName)
/*  979 */      $(context).trigger(event, data)
/*  980 */      return !event.defaultPrevented
/*  981 */    }
/*  982 */  
/*  983 */    // trigger an Ajax "global" event
/*  984 */    function triggerGlobal(settings, context, eventName, data) {
/*  985 */      if (settings.global) return triggerAndReturn(context || document, eventName, data)
/*  986 */    }
/*  987 */  
/*  988 */    // Number of active Ajax requests
/*  989 */    $.active = 0
/*  990 */  
/*  991 */    function ajaxStart(settings) {
/*  992 */      if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')
/*  993 */    }
/*  994 */    function ajaxStop(settings) {
/*  995 */      if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')
/*  996 */    }
/*  997 */  
/*  998 */    // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
/*  999 */    function ajaxBeforeSend(xhr, settings) {
/* 1000 */      var context = settings.context
/* 1001 */      if (settings.beforeSend.call(context, xhr, settings) === false ||
/* 1002 */          triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)
/* 1003 */        return false
/* 1004 */  
/* 1005 */      triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])
/* 1006 */    }
/* 1007 */    function ajaxSuccess(data, xhr, settings) {
/* 1008 */      var context = settings.context, status = 'success'
/* 1009 */      settings.success.call(context, data, status, xhr)
/* 1010 */      triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])
/* 1011 */      ajaxComplete(status, xhr, settings)
/* 1012 */    }
/* 1013 */    // type: "timeout", "error", "abort", "parsererror"
/* 1014 */    function ajaxError(error, type, xhr, settings) {
/* 1015 */      var context = settings.context
/* 1016 */      settings.error.call(context, xhr, type, error)
/* 1017 */      triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error])
/* 1018 */      ajaxComplete(type, xhr, settings)
/* 1019 */    }
/* 1020 */    // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
/* 1021 */    function ajaxComplete(status, xhr, settings) {
/* 1022 */      var context = settings.context
/* 1023 */      settings.complete.call(context, xhr, status)
/* 1024 */      triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])
/* 1025 */      ajaxStop(settings)
/* 1026 */    }
/* 1027 */  
/* 1028 */    // Empty function, used as default callback
/* 1029 */    function empty() {}
/* 1030 */  
/* 1031 */    $.ajaxJSONP = function(options){
/* 1032 */      var callbackName = 'jsonp' + (++jsonpID),
/* 1033 */        script = document.createElement('script'),
/* 1034 */        abort = function(){
/* 1035 */          $(script).remove()
/* 1036 */          if (callbackName in window) window[callbackName] = empty
/* 1037 */          ajaxComplete('abort', xhr, options)
/* 1038 */        },
/* 1039 */        xhr = { abort: abort }, abortTimeout
/* 1040 */  
/* 1041 */      if (options.error) script.onerror = function() {
/* 1042 */        xhr.abort()
/* 1043 */        options.error()
/* 1044 */      }
/* 1045 */  
/* 1046 */      window[callbackName] = function(data){
/* 1047 */        clearTimeout(abortTimeout)
/* 1048 */        $(script).remove()
/* 1049 */        delete window[callbackName]
/* 1050 */        ajaxSuccess(data, xhr, options)
/* 1051 */      }
/* 1052 */  
/* 1053 */      serializeData(options)
/* 1054 */      script.src = options.url.replace(/=\?/, '=' + callbackName)
/* 1055 */      $('head').append(script)
/* 1056 */  
/* 1057 */      if (options.timeout > 0) abortTimeout = setTimeout(function(){
/* 1058 */          xhr.abort()
/* 1059 */          ajaxComplete('timeout', xhr, options)
/* 1060 */        }, options.timeout)
/* 1061 */  
/* 1062 */      return xhr
/* 1063 */    }
/* 1064 */  
/* 1065 */    $.ajaxSettings = {
/* 1066 */      // Default type of request
/* 1067 */      type: 'GET',
/* 1068 */      // Callback that is executed before request
/* 1069 */      beforeSend: empty,
/* 1070 */      // Callback that is executed if the request succeeds
/* 1071 */      success: empty,
/* 1072 */      // Callback that is executed the the server drops error
/* 1073 */      error: empty,
/* 1074 */      // Callback that is executed on request complete (both: error and success)
/* 1075 */      complete: empty,
/* 1076 */      // The context for the callbacks
/* 1077 */      context: null,
/* 1078 */      // Whether to trigger "global" Ajax events
/* 1079 */      global: true,
/* 1080 */      // Transport
/* 1081 */      xhr: function () {
/* 1082 */        return new window.XMLHttpRequest()
/* 1083 */      },
/* 1084 */      // MIME types mapping
/* 1085 */      accepts: {
/* 1086 */        script: 'text/javascript, application/javascript',
/* 1087 */        json:   jsonType,
/* 1088 */        xml:    'application/xml, text/xml',
/* 1089 */        html:   htmlType,
/* 1090 */        text:   'text/plain'
/* 1091 */      },
/* 1092 */      // Whether the request is to another domain
/* 1093 */      crossDomain: false,
/* 1094 */      // Default timeout
/* 1095 */      timeout: 0
/* 1096 */    }
/* 1097 */  
/* 1098 */    function mimeToDataType(mime) {
/* 1099 */      return mime && ( mime == htmlType ? 'html' :
/* 1100 */        mime == jsonType ? 'json' :
/* 1101 */        scriptTypeRE.test(mime) ? 'script' :
/* 1102 */        xmlTypeRE.test(mime) && 'xml' ) || 'text'
/* 1103 */    }
/* 1104 */  
/* 1105 */    function appendQuery(url, query) {
/* 1106 */      return (url + '&' + query).replace(/[&?]{1,2}/, '?')
/* 1107 */    }
/* 1108 */  
/* 1109 */    // serialize payload and append it to the URL for GET requests
/* 1110 */    function serializeData(options) {
/* 1111 */      if (isObject(options.data)) options.data = $.param(options.data)
/* 1112 */      if (options.data && (!options.type || options.type.toUpperCase() == 'GET'))
/* 1113 */        options.url = appendQuery(options.url, options.data)
/* 1114 */    }
/* 1115 */  
/* 1116 */    $.ajax = function(options){
/* 1117 */      var settings = $.extend({}, options || {})
/* 1118 */      for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]
/* 1119 */  
/* 1120 */      ajaxStart(settings)
/* 1121 */  
/* 1122 */      if (!settings.crossDomain) settings.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(settings.url) &&
/* 1123 */        RegExp.$2 != window.location.host
/* 1124 */  
/* 1125 */      var dataType = settings.dataType, hasPlaceholder = /=\?/.test(settings.url)
/* 1126 */      if (dataType == 'jsonp' || hasPlaceholder) {
/* 1127 */        if (!hasPlaceholder) settings.url = appendQuery(settings.url, 'callback=?')
/* 1128 */        return $.ajaxJSONP(settings)
/* 1129 */      }
/* 1130 */  
/* 1131 */      if (!settings.url) settings.url = window.location.toString()
/* 1132 */      serializeData(settings)
/* 1133 */  
/* 1134 */      var mime = settings.accepts[dataType],
/* 1135 */          baseHeaders = { },
/* 1136 */          protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
/* 1137 */          xhr = $.ajaxSettings.xhr(), abortTimeout
/* 1138 */  
/* 1139 */      if (!settings.crossDomain) baseHeaders['X-Requested-With'] = 'XMLHttpRequest'
/* 1140 */      if (mime) {
/* 1141 */        baseHeaders['Accept'] = mime
/* 1142 */        if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]
/* 1143 */        xhr.overrideMimeType && xhr.overrideMimeType(mime)
/* 1144 */      }
/* 1145 */      if (settings.contentType || (settings.data && settings.type.toUpperCase() != 'GET'))
/* 1146 */        baseHeaders['Content-Type'] = (settings.contentType || 'application/x-www-form-urlencoded')
/* 1147 */      settings.headers = $.extend(baseHeaders, settings.headers || {})
/* 1148 */  
/* 1149 */      xhr.onreadystatechange = function(){
/* 1150 */        if (xhr.readyState == 4) {
/* 1151 */          clearTimeout(abortTimeout)
/* 1152 */          var result, error = false
/* 1153 */          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {
/* 1154 */            dataType = dataType || mimeToDataType(xhr.getResponseHeader('content-type'))
/* 1155 */            result = xhr.responseText
/* 1156 */  
/* 1157 */            try {
/* 1158 */              if (dataType == 'script')    (1,eval)(result)
/* 1159 */              else if (dataType == 'xml')  result = xhr.responseXML
/* 1160 */              else if (dataType == 'json') result = blankRE.test(result) ? null : JSON.parse(result)
/* 1161 */            } catch (e) { error = e }
/* 1162 */  
/* 1163 */            if (error) ajaxError(error, 'parsererror', xhr, settings)
/* 1164 */            else ajaxSuccess(result, xhr, settings)
/* 1165 */          } else {
/* 1166 */            ajaxError(null, 'error', xhr, settings)
/* 1167 */          }
/* 1168 */        }
/* 1169 */      }
/* 1170 */  
/* 1171 */      var async = 'async' in settings ? settings.async : true
/* 1172 */      xhr.open(settings.type, settings.url, async)
/* 1173 */  
/* 1174 */      for (name in settings.headers) xhr.setRequestHeader(name, settings.headers[name])
/* 1175 */  
/* 1176 */      if (ajaxBeforeSend(xhr, settings) === false) {
/* 1177 */        xhr.abort()
/* 1178 */        return false
/* 1179 */      }
/* 1180 */  
/* 1181 */      if (settings.timeout > 0) abortTimeout = setTimeout(function(){
/* 1182 */          xhr.onreadystatechange = empty
/* 1183 */          xhr.abort()
/* 1184 */          ajaxError(null, 'timeout', xhr, settings)
/* 1185 */        }, settings.timeout)
/* 1186 */  
/* 1187 */      // avoid sending empty string (#319)
/* 1188 */      xhr.send(settings.data ? settings.data : null)
/* 1189 */      return xhr
/* 1190 */    }
/* 1191 */  
/* 1192 */    $.get = function(url, success){ return $.ajax({ url: url, success: success }) }
/* 1193 */  
/* 1194 */    $.post = function(url, data, success, dataType){
/* 1195 */      if ($.isFunction(data)) dataType = dataType || success, success = data, data = null
/* 1196 */      return $.ajax({ type: 'POST', url: url, data: data, success: success, dataType: dataType })
/* 1197 */    }
/* 1198 */  
/* 1199 */    $.getJSON = function(url, success){
/* 1200 */      return $.ajax({ url: url, success: success, dataType: 'json' })
/* 1201 */    }
/* 1202 */  
/* 1203 */    $.fn.load = function(url, success){
/* 1204 */      if (!this.length) return this
/* 1205 */      var self = this, parts = url.split(/\s/), selector
/* 1206 */      if (parts.length > 1) url = parts[0], selector = parts[1]
/* 1207 */      $.get(url, function(response){
/* 1208 */        self.html(selector ?
/* 1209 */          $(document.createElement('div')).html(response.replace(rscript, "")).find(selector).html()
/* 1210 */          : response)
/* 1211 */        success && success.call(self)
/* 1212 */      })
/* 1213 */      return this
/* 1214 */    }
/* 1215 */  
/* 1216 */    var escape = encodeURIComponent
/* 1217 */  
/* 1218 */    function serialize(params, obj, traditional, scope){
/* 1219 */      var array = $.isArray(obj)
/* 1220 */      $.each(obj, function(key, value) {
/* 1221 */        if (scope) key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'
/* 1222 */        // handle data in serializeArray() format
/* 1223 */        if (!scope && array) params.add(value.name, value.value)
/* 1224 */        // recurse into nested objects
/* 1225 */        else if (traditional ? $.isArray(value) : isObject(value))
/* 1226 */          serialize(params, value, traditional, key)
/* 1227 */        else params.add(key, value)
/* 1228 */      })
/* 1229 */    }
/* 1230 */  
/* 1231 */    $.param = function(obj, traditional){
/* 1232 */      var params = []
/* 1233 */      params.add = function(k, v){ this.push(escape(k) + '=' + escape(v)) }
/* 1234 */      serialize(params, obj, traditional)
/* 1235 */      return params.join('&').replace('%20', '+')
/* 1236 */    }
/* 1237 */  })(Zepto)
/* 1238 */  ;(function ($) {
/* 1239 */    $.fn.serializeArray = function () {
/* 1240 */      var result = [], el
/* 1241 */      $( Array.prototype.slice.call(this.get(0).elements) ).each(function () {
/* 1242 */        el = $(this)
/* 1243 */        var type = el.attr('type')
/* 1244 */        if (this.nodeName.toLowerCase() != 'fieldset' &&
/* 1245 */          !this.disabled && type != 'submit' && type != 'reset' && type != 'button' &&
/* 1246 */          ((type != 'radio' && type != 'checkbox') || this.checked))
/* 1247 */          result.push({
/* 1248 */            name: el.attr('name'),
/* 1249 */            value: el.val()
/* 1250 */          })
/* 1251 */      })
/* 1252 */      return result
/* 1253 */    }
/* 1254 */  
/* 1255 */    $.fn.serialize = function () {
/* 1256 */      var result = []
/* 1257 */      this.serializeArray().forEach(function (elm) {
/* 1258 */        result.push( encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value) )
/* 1259 */      })
/* 1260 */      return result.join('&')
/* 1261 */    }
/* 1262 */  
/* 1263 */    $.fn.submit = function (callback) {
/* 1264 */      if (callback) this.bind('submit', callback)
/* 1265 */      else if (this.length) {
/* 1266 */        var event = $.Event('submit')
/* 1267 */        this.eq(0).trigger(event)
/* 1268 */        if (!event.defaultPrevented) this.get(0).submit()
/* 1269 */      }
/* 1270 */      return this
/* 1271 */    }
/* 1272 */  
/* 1273 */  })(Zepto)
/* 1274 */  ;(function($){
/* 1275 */    var touch = {}, touchTimeout
/* 1276 */  
/* 1277 */    function parentIfText(node){
/* 1278 */      return 'tagName' in node ? node : node.parentNode
/* 1279 */    }
/* 1280 */  
/* 1281 */    function swipeDirection(x1, x2, y1, y2){
/* 1282 */      var xDelta = Math.abs(x1 - x2), yDelta = Math.abs(y1 - y2)
/* 1283 */      return xDelta >= yDelta ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down')
/* 1284 */    }
/* 1285 */  
/* 1286 */    var longTapDelay = 750, longTapTimeout
/* 1287 */  
/* 1288 */    function longTap(){
/* 1289 */      longTapTimeout = null
/* 1290 */      if (touch.last) {
/* 1291 */        touch.el.trigger('longTap')
/* 1292 */        touch = {}
/* 1293 */      }
/* 1294 */    }
/* 1295 */  
/* 1296 */    function cancelLongTap(){
/* 1297 */      if (longTapTimeout) clearTimeout(longTapTimeout)
/* 1298 */      longTapTimeout = null
/* 1299 */    }
/* 1300 */  
/* 1301 */    $(document).ready(function(){
/* 1302 */      var now, delta
/* 1303 */  
/* 1304 */      $(document.body).bind('touchstart', function(e){
/* 1305 */        now = Date.now()
/* 1306 */        delta = now - (touch.last || now)
/* 1307 */        touch.el = $(parentIfText(e.touches[0].target))
/* 1308 */        touchTimeout && clearTimeout(touchTimeout)
/* 1309 */        touch.x1 = e.touches[0].pageX
/* 1310 */        touch.y1 = e.touches[0].pageY
/* 1311 */        if (delta > 0 && delta <= 250) touch.isDoubleTap = true
/* 1312 */        touch.last = now
/* 1313 */        longTapTimeout = setTimeout(longTap, longTapDelay)
/* 1314 */      }).bind('touchmove', function(e){
/* 1315 */        cancelLongTap()
/* 1316 */        touch.x2 = e.touches[0].pageX
/* 1317 */        touch.y2 = e.touches[0].pageY
/* 1318 */      }).bind('touchend', function(e){
/* 1319 */         cancelLongTap()
/* 1320 */  
/* 1321 */        // double tap (tapped twice within 250ms)
/* 1322 */        if (touch.isDoubleTap) {
/* 1323 */          touch.el.trigger('doubleTap')
/* 1324 */          touch = {}
/* 1325 */  
/* 1326 */        // swipe
/* 1327 */        } else if ((touch.x2 && Math.abs(touch.x1 - touch.x2) > 30) ||
/* 1328 */                   (touch.y2 && Math.abs(touch.y1 - touch.y2) > 30)) {
/* 1329 */          touch.el.trigger('swipe') &&
/* 1330 */            touch.el.trigger('swipe' + (swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2)))
/* 1331 */          touch = {}
/* 1332 */  
/* 1333 */        // normal tap
/* 1334 */        } else if ('last' in touch) {
/* 1335 */          touch.el.trigger('tap')
/* 1336 */  
/* 1337 */          touchTimeout = setTimeout(function(){
/* 1338 */            touchTimeout = null
/* 1339 */            touch.el.trigger('singleTap')
/* 1340 */            touch = {}
/* 1341 */          }, 250)
/* 1342 */        }
/* 1343 */      }).bind('touchcancel', function(){
/* 1344 */        if (touchTimeout) clearTimeout(touchTimeout)
/* 1345 */        if (longTapTimeout) clearTimeout(longTapTimeout)
/* 1346 */        longTapTimeout = touchTimeout = null
/* 1347 */        touch = {}
/* 1348 */      })
/* 1349 */    })
/* 1350 */  
/* 1351 */    ;['swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown', 'doubleTap', 'tap', 'singleTap', 'longTap'].forEach(function(m){
/* 1352 */      $.fn[m] = function(callback){ return this.bind(m, callback) }
/* 1353 */    })
/* 1354 */  })(Zepto)
/* 1355 */  

/**
 * js/analytics.js
 */

/*    0 */  var _gaq = [['_setAccount','UA-33130237-1'],['_trackPageview']]
/*    1 */  ;(function () {
/*    2 */    var script = document.createElement('script')
/*    3 */    script.src = ('https:' === location.protocol ? '//ssl':'//www') + '.google-analytics.com/ga.js'
/*    4 */    document.head.appendChild(script)
/*    5 */  }())

/**
 * js/main.js
 */

/*    0 */  /*global TweenLite io*/
/*    1 */  
/*    2 */  $().ready(function () {
/*    3 */    "use strict";
/*    4 */  
/*    5 */    var guests = {}
/*    6 */    var socket = io.connect()
/*    7 */    var octocat = $('#github')
/*    8 */    var offsetLeft, offsetTop
/*    9 */  
/*   10 */    socket.on('connect', function () {
/*   11 */      $(window).on('mousemove', function (e) {
/*   12 */        socket.emit('move', {
/*   13 */          x: e.clientX - offsetLeft,
/*   14 */          y: e.clientY - offsetTop
/*   15 */        })
/*   16 */      }).on('resize', function () {
/*   17 */        var offset = octocat.offset()
/*   18 */        offsetTop = offset.top
/*   19 */        offsetLeft = offset.left
/*   20 */        console.dir(offset)
/*   21 */      }).trigger('resize')
/*   22 */    }).on('move', function (data) {
/*   23 */      var guest = guests[data.id]
/*   24 */      if (guest === undefined) {
/*   25 */        guests[data.id] = guest = $('<div class="pointer">').css({
/*   26 */          left: data.x - 5 + offsetTop,
/*   27 */          top: data.y - 5 + offsetLeft
/*   28 */        }).appendTo(document.body)[0]
/*   29 */        TweenLite.to(guest, 1, { css: { opacity: 0.5 } })
/*   30 */      }
/*   31 */      TweenLite.to(guest, 0.5, { css: {
/*   32 */        left: data.x - 5 + offsetLeft,
/*   33 */        top: data.y - 5 + offsetTop
/*   34 */      }})
/*   35 */    }).on('disconnect', function (id) {
/*   36 */      var guest = guests[id]
/*   37 */      if (!guest) return
/*   38 */      TweenLite.to(guest, 0.5, { css: { opacity: 0 }, onComplete: function () {
/*   39 */          $(guest).remove()
/*   40 */          ;delete guests[id]
/*   41 */      }})
/*   42 */    })
/*   43 */  })

